Está ocorrendo um erro de existência de nulos na sua variável exercicio11b
 
provavelmente pela presença da coluna QT_RCLM_CLI
 
Nós rodamos os modelos enviados para validar seus dados, então exclua essa coluna do exercicio11b
 
variaveis_preditivas = exercicio10b.columns[:21]  # Ajuste conforme necessário para selecionar as variáveis certas

 
Aqui você está pegando as primeiras colnas
 
Selecione com outro critério ou simplesmente exclua a QT_RCLM_CLI
 
Nós usamos as variáveis do 11 para validar o 12
 
No caso, exercicio12e.predict(exercicio11b) está ocasionando um erro. Pode testar aí no seu, vai ver que ocorre
 
# 1. Imputação de dados faltantes

imputador = SimpleImputer(strategy='mean')

X_train_imputado = imputador.fit_transform(exercicio11a)

X_test_imputado = imputador.transform(exercicio11b)
 
Estou vendo que treinou com outra variável, que não as do exercicio 11
 
Nós vamos usar essas variáveis para validar, as do exercício 11
 
Então você deve treinar com elas
 
Mesma coisa com escalonamento,
# 2. Escalonamento dos dados

escalonador = StandardScaler()

X_train_escalado = escalonador.fit_transform(X_train_imputado)

X_test_escalado = escalonador.transform(X_test_imputado)
 
Não deve transformar depois pois usamos as variáveis do 11 para validar.
 
E o erro está relacionado com os valores nulos na coluna QT_RCLM_CLI que ocasionam em erro no validador.
 
Você evita esse erro com o seu imputer em cima das variáveis do 11, mas no validador, vamos usar a do 11
 
Bom dia, Alexandre, vou dar uma olhada no seu caso, mas o validador está funcionando corretamente e normalmente, vou ver se seu caderno está ocasionando um erro
 
O valor do F1Score obtido pelo validador para regressão logística está dando 0.0
 

Você está transformando os dados para treinar e prever... Claro que não vai dar certo. Tem que usar as variáveis do exercício 11, sem escalar, sem imputar, pois nós vamos usar as variáveis para bater os valores de F1Score
 
# 2. Escalonamento dos dados (apenas para modelos que necessitam)

escalonador = StandardScaler()
 
# Ajustar o escalonador nos dados de treino e aplicar nos dados de teste

X_train_escalado = escalonador.fit_transform(X_train)

X_test_escalado = escalonador.transform(X_test)

 
Alexandre, no ex. 9 já é realizado o escalonamento dos dados pelo método minmax. 
 
Não tem a necessidade de fazer um novo escalonamento pelo método de normalização z. 
 
Além disso, o validador usa as variáveis do ex. 11 para validar o ex. 12, e como vc treina com os dados escalonados, na hora de validar, o validador irá predizer com os dados não escalonados, ou seja, o resultado vai estar bem alterado e o f1 vai tender à zero por causa dessa mudança de escala.
