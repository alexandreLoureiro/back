CREATE OR REPLACE FUNCTION notify_status_gpt_change() 
RETURNS trigger AS $$
DECLARE
    payload JSON;
BEGIN
    -- Verifica se a coluna status_gpt foi alterada
    IF NEW.status_gpt IS DISTINCT FROM OLD.status_gpt THEN
        -- Monta o JSON com os campos desejados
        payload := json_build_object(
            'id', NEW.id,
            'relatorio', NEW.relatorio,
            'periodo_apuracao', NEW.periodo_apuracao,
            'data_emissao', NEW.data_emissao
        );
        -- Envia a notificação para um canal específico (você pode escolher o nome do canal)
        PERFORM pg_notify('rcm_kpmg_status_changed', payload::text);
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_notify_status_gpt_change
AFTER UPDATE OF status_gpt ON rcm.rcm_kpmg_relatorios
FOR EACH ROW
EXECUTE FUNCTION notify_status_gpt_change();

import asyncio
import asyncpg
import json
import logging
from infra.sqlalchemy.config.database_pool import get_connection
from routers.rotas_geral import manager  # Certifique-se de que o manager está importado corretamente

logger = logging.getLogger(__name__)

async def listen_to_db_notifications():
    while True:
        try:
            conn = await get_connection()
            logger.info("Conectado ao PostgreSQL para escutar notificações.")
            
            def notification_handler(connection, pid, channel, payload):
                logger.info(f"Notificação recebida no canal {channel}: {payload}")
                try:
                    data = json.loads(payload)
                    # Extraindo os campos enviados pela trigger nova
                    id_relatorio = data.get("id")
                    relatorio = data.get("relatorio")
                    periodo_apuracao = data.get("periodo_apuracao")
                    data_emissao = data.get("data_emissao")
                    
                    # Se o campo id estiver presente, envia a mensagem
                    if id_relatorio is not None:
                        message = (
                            f"Relatório '{relatorio}' (ID: {id_relatorio}) alterado. "
                            f"Período de Apuração: {periodo_apuracao}, Data de Emissão: {data_emissao}."
                        )
                        asyncio.create_task(manager.broadcast(message))
                except Exception as e:
                    logger.error("Erro ao processar payload: %s", e)
            
            # Alterar o canal para o novo utilizado pela trigger, por exemplo:
            await conn.add_listener('rcm_kpmg_status_changed', notification_handler)
            logger.info("Listener registrado para o canal 'rcm_kpmg_status_changed'.")
            
            # Loop de keep-alive: executa uma query simples a cada segundo
            while True:
                await asyncio.sleep(1)
                try:
                    await conn.execute("SELECT 1")
                except Exception as e:
                    logger.error("Erro no keep-alive da conexão: %s", e)
                    break  # Sai do loop interno para reconectar
        except Exception as e:
            logger.error(f"Erro na conexão de notificações: {e}")
        logger.info("Tentando reconectar em 5 segundos...")
        await asyncio.sleep(5)




eu tenho essa implementacao de websocket no fastapi: import asyncio
import asyncpg
import json
import logging
from infra.sqlalchemy.config.database_pool import get_connection
from routers.rotas_geral import manager  # Certifique-se de que o manager está importado corretamente

logger = logging.getLogger(__name__)

async def listen_to_db_notifications():
    while True:
        try:
            conn = await get_connection()
            logger.info("Conectado ao PostgreSQL para escutar notificações.")
            
            def notification_handler(connection, pid, channel, payload):
                logger.info(f"Notificação recebida no canal {channel}: {payload}")
                try:
                    data = json.loads(payload)
                    nr_trabalho = data.get("nr_trabalho")
                    alerta_evt_risco = data.get("alerta_evt_risco")
                    if nr_trabalho is not None and alerta_evt_risco:
                        message = f"Produto {nr_trabalho} alterado. Alerta: {alerta_evt_risco}"
                        asyncio.create_task(manager.broadcast(message))
                except Exception as e:
                    logger.error("Erro ao processar payload: %s", e)
            
            await conn.add_listener('row_changed', notification_handler)
            logger.info("Listener registrado para o canal 'row_changed'.")
            
            # Loop de keep-alive: executa uma query simples a cada segundo
            while True:
                await asyncio.sleep(1)
                try:
                    await conn.execute("SELECT 1")
                except Exception as e:
                    logger.error("Erro no keep-alive da conexão: %s", e)
                    break  # Sai do loop interno para reconectar
        except Exception as e:
            logger.error(f"Erro na conexão de notificações: {e}")
        logger.info("Tentando reconectar em 5 segundos...")
        await asyncio.sleep(5) na epoca tinha criado essa triguer: 
 DECLARE
     payload JSON;
 BEGIN
     -- Se o valor de alerta_evt_risco mudou, envia a notificação
     IF NEW.alerta_evt_risco IS DISTINCT FROM OLD.alerta_evt_risco THEN
         payload := json_build_object(
             'nr_trabalho', NEW.nr_trabalho,
             'alerta_evt_risco', NEW.alerta_evt_risco
         );
         PERFORM pg_notify('row_changed', payload::text);
     END IF;
     RETURN NEW;
 END; só que agora preciso criar uma triguer nesse esquema e pega essa tabela: rcm.rcm_kpmg_relatorios , o que eu quero é que sempre que a coluna status_gpt tiver alteração eu receba a mensagem com o campo id, relatorio, periodo_apuracao e data_emissao, nao preciso mais ver ficar ouvindo a triger anterior, como faço/
