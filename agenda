Você receberá um relatório de auditoria externa completo no campo {relatorio}. Sua tarefa é gerar dois atributos, utilizando formatação innerHTML com tags HTML, da seguinte forma:

1. **sumario_executivo**:  
   - Crie um sumário executivo curto, composto por poucas frases, que destaque os principais pontos do relatório, com ênfase nos riscos relevantes e achados significativos que realmente valem a pena ser citados para a alta administração do banco.  
   - O texto deve ser profissional, como um resumo de auditoria, podendo utilizar elementos como **negrito** para destacar pontos importantes, ícones e outros elementos visuais que façam sentido para a apresentação.  
   - Após essa frase ou conjunto de frases, em uma nova linha, adicione, em itálico, uma frase curta contendo o texto original da extração (ou parte dele) para facilitar a consulta pelo auditor.

2. **racional_sumario**:  
   - Forneça uma explicação sucinta do raciocínio adotado para a seleção dos pontos destacados no sumário. Essa explicação deve contextualizar os critérios utilizados e ajudar o auditor a entender a relevância dos pontos escolhidos.

Retorne o resultado em formato JSON puro, sem qualquer marcação extra, seguindo o exemplo abaixo:

{
  "sumario_executivo": "<p><strong>Principal ponto:</strong> [Texto resumido com destaques e ícones se aplicável].<br><em>[Texto original resumido da extração]</em></p>",
  "racional_sumario": "[Explicação do raciocínio adotado para a elaboração do sumário]"
}



import pandas as pd
from sqlalchemy import create_engine, inspect, text

# Supondo que a função 'postgres()' já esteja definida e retorne (conn, engine)
conn, engine = postgres()

# Nome da tabela e do schema
table_name = "rcm_kpmg_relatorios"
schema_name = "rcm"

# Lista de colunas a serem criadas (coluna: tipo de dados)
columns_to_add = {
    'achou_constatacao': 'TEXT',
    'achou_recomendacao': 'TEXT',
    'dica_localizar_constatacao': 'TEXT',
    'dica_localizar_recomendacao': 'TEXT',
    'conf_implementacao': 'TEXT',
    'racional': 'TEXT',
    'resumo_constatacao': 'TEXT',
    'resumo_recomendacao': 'TEXT'
}

# Cria um inspetor para verificar as colunas existentes
inspector = inspect(engine)
existing_columns = [col['name'] for col in inspector.get_columns(table_name, schema=schema_name)]

# Abre uma conexão de transação para realizar os ALTER TABLE se necessário
with engine.begin() as connection:
    for col, data_type in columns_to_add.items():
        if col not in existing_columns:
            alter_sql = f"ALTER TABLE {schema_name}.{table_name} ADD COLUMN {col} {data_type};"
            connection.execute(text(alter_sql))
            print(f"Coluna '{col}' adicionada à tabela {schema_name}.{table_name}.")

# Agora, para cada linha do DataFrame df_gpt, fazemos um UPDATE na tabela
update_query = text(f"""
    UPDATE {schema_name}.{table_name}
    SET 
        achou_constatacao = :achou_constatacao,
        achou_recomendacao = :achou_recomendacao,
        dica_localizar_constatacao = :dica_localizar_constatacao,
        dica_localizar_recomendacao = :dica_localizar_recomendacao,
        conf_implementacao = :conf_implementacao,
        racional = :racional,
        resumo_constatacao = :resumo_constatacao,
        resumo_recomendacao = :resumo_recomendacao
    WHERE id = :id
""")

# Realiza os updates para cada registro baseado na coluna 'id'
with engine.begin() as connection:
    for index, row in df_gpt.iterrows():
        params = {
            'id': row['id'],
            'achou_constatacao': row['achou_constatacao'],
            'achou_recomendacao': row['achou_recomendacao'],
            'dica_localizar_constatacao': row['dica_localizar_constatacao'],
            'dica_localizar_recomendacao': row['dica_localizar_recomendacao'],
            'conf_implementacao': row['conf_implementacao'],
            'racional': row['racional'],
            'resumo_constatacao': row['resumo_constatacao'],
            'resumo_recomendacao': row['resumo_recomendacao']
        }
        connection.execute(update_query, **params)
        print(f"Registro com id {row['id']} atualizado.")

print("Processamento concluído.")



ok, agora tenho esse dataframe:

df_gpt[['id', 'achou_constatacao', 'achou_recomendacao',
       'dica_localizar_constatacao', 'dica_localizar_recomendacao',
       'conf_implementacao', 'racional', 'resumo_constatacao',
       'resumo_recomendacao']].head()

já tenho minha conexao:

conn, engine = postgres()
base_query = """
SELECT id, constatacoes, evidencias, recomendacao, relatorio_text_extract, previsao_implementacao, gpt_id
FROM rcm.rcm_kpmg_relatorios where gpt_id is null;
"""
df = pd.read_sql(base_query, engine)

antes fazia assim: 

df_resultados.to_sql(
                name=table_name,
                con=engine,
                schema=schema_name,
                if_exists='append',  # ou 'append'
                index=False
            )
            logging.info(f"Processamento concluído. {len(resultados)} registros inseridos no banco de dados.")

agora eu que criar se nao exisitr as colunas 'achou_constatacao', 'achou_recomendacao',
       'dica_localizar_constatacao', 'dica_localizar_recomendacao',
       'conf_implementacao', 'racional', 'resumo_constatacao',
       'resumo_recomendacao' em rcm.rcm_kpmg_relatorios e depois 
fazer um update por id dos valores dessas colunas do dataframe na minha tabela postgres
