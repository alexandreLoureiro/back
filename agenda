CREATE SCHEMA IF NOT EXISTS rcm;

CREATE TABLE IF NOT EXISTS rcm.rcm_relatorios (
  id SERIAL PRIMARY KEY,
  relatorio VARCHAR(255) NOT NULL,                     -- corresponde à coluna RELATORIO
  data_emissao TEXT NOT NULL,                          -- armazena a data de emissão como texto (ex.: "20/09/2024")
  constatacoes TEXT,                                   -- corresponde à coluna CONSTATACAO
  evidencias TEXT,                                     -- corresponde à coluna EVIDENCIAS
  recomendacao TEXT,                                   -- corresponde à coluna RECOMENDACAO
  instituicao_responsavel VARCHAR(255),                -- corresponde à coluna INSTITUICAO_RESPONSAVEL
  prefixo_responsavel VARCHAR(255),                    -- corresponde à coluna PREFIXO_RESPONSAVEL
  instituicao_assunto_elbb VARCHAR(255),               -- corresponde à coluna INSTITUICAO_ASSUNTO_ELBB
  previsao_implementacao TEXT,                         -- corresponde à coluna PREVISAO_IMPLEMENTACAO
  matricula_do_gestor_responsavel VARCHAR(50),         -- corresponde à coluna MATRICULA_DO_GESTOR_RESPONSAVEL
  pdf_file BYTEA,                                      -- armazena o PDF como blob
  dt_inserido TIMESTAMP DEFAULT NOW()
);

import { Injectable } from '@angular/core';
import { HttpClient, HttpErrorResponse, HttpHeaders } from '@angular/common/http';
import { BehaviorSubject, Observable, of, throwError } from 'rxjs';
import { catchError, map } from 'rxjs/operators';
import { environment } from '../environments/environment';

import { MensagemPayload } from './models/models';

import { FeedbackPayload } from './models/models';

import { MensagemPayloadGeral } from './models/models';

// No seu servico-llm.service.ts
export interface RcmRelatorio {
  id: number;
  nome: string;
  data_emissao: string | null;
  constatacoes: string;
  recomendacoes: string;
}



@Injectable({
  providedIn: 'root'
})
export class ServicoLLMService {

  private APIprod = 'http://10.2.96.55:5000/api';

  //private API_LOCAL = 'http://192.168.2.80:5002/apilocal';
  //private API = 'http://192.168.2.80/api';
private API_ptai = 'http://192.168.2.80:5002/apiptai';
private API_ptaiDocker = "http://192.168.2.80:5002/apiptai"

//private API_ptaiDocker = "https://mefis.bb.com.br/apiptai"
//private API_ptai = 'https://mefis.bb.com.br/apilocal';
private API = "https://mefis.bb.com.br/api"
//private API_ptai_ = "https://mefis.bb.com.br/apiptai"

  // =============================
  // ARMAZENAMENTO DE USUÁRIO
  // =============================
  private userSubject = new BehaviorSubject<any>(null);
  /** Observable para quem quiser “ouvir” mudanças no usuário. */
  public user$ = this.userSubject.asObservable();

  // =============================
  // CONSTRUTOR
  // =============================
  constructor(private http: HttpClient) {}

  // =============================
  // MÉTODOS DE GESTÃO DO USUÁRIO
  // =============================
  /**
   * Define o usuário atual no BehaviorSubject.
   */
  setUser(user: any) {
    this.userSubject.next(user);
  }

  /**
   * Retorna o valor atual do usuário (sem precisar se inscrever).
   */
  getUser() {
    return this.userSubject.value;
  }

  // =============================
  // MÉTODOS DE AUTENTICAÇÃO
  // =============================
  authFunci(goto: any) {
    return this.http.post<any>(`${this.API_ptai}/auth/`, goto);
  }

  getFuncionario() {
    return this.http.get<any>(`${this.API}/authrest`);
  }

  getAuthFunci() {
    return this.http.get<any>(`${this.API}/authrestfunci`);
  }

  /**
   * Chama o backend para autenticar via corpo (com goto e environment).
   * Se retornar user, armazenamos no BehaviorSubject para uso global.
   */
  getauthrestfunci(goto: string): Observable<any> {
    if (!goto) {
      console.error('Parâmetro "goto" é obrigatório.');
      return throwError(() => new Error('Parâmetro "goto" é obrigatório.'));
    }

    const body = {
      goto,
      environment: environment.environmentName,
    };

    return this.http.post<any>(`${this.API_ptai}/authrestfunci/`, body).pipe(
      map((response) => {
        if (response?.redirectUrl) {
          window.location.href = response.redirectUrl;
        }
        return response;
      }),
      catchError((error) => {
        console.error('Erro na autenticação:', error);
        return throwError(() => new Error('Erro ao autenticar. Por favor, tente novamente.'));
      })
    );
  }

  // =============================
  // MÉTODOS DE CHAT E OUTROS
  // =============================
  sendMessage(
    sessionId: string,
    userMessage: string,
    roleUser?: string,
    roleAssistant?: string
  ): Observable<any> {
    const body = { sessionId, userMessage, roleUser, roleAssistant };
    return this.http.post<any>(`${this.API_ptai}/chat`, body).pipe(
      catchError((error: HttpErrorResponse) => {
        let errorMessage = 'Erro desconhecido. Por favor, tente novamente mais tarde.';

        if (error.error instanceof ErrorEvent) {
          // Erro do lado do cliente
          errorMessage = `Erro do cliente: ${error.error.message}`;
        } else {
          // Erro do lado do servidor
          switch (error.status) {
            case 400:
              errorMessage = 'Requisição inválida. Verifique os dados enviados.';
              break;
            case 500:
              errorMessage = 'Erro interno no servidor. Por favor, tente novamente mais tarde.';
              break;
            default:
              errorMessage = `Erro (${error.status}): ${error.message}`;
          }
        }

        console.error('Erro na chamada ao backend:', error);
        return throwError(() => new Error(errorMessage));
      })
    );
  }

  getTrabalhos(request: { nome: string; ano: number }): Observable<any[]> {
    return this.http.post<any[]>(`${this.API_ptai}/chat_trabalhos/`, request);
  }

  getTrabalhoDetails(nr_trabalho: number): Observable<any> {
    return this.http.post(`${this.API_ptai}/chat_trabalho/`, { nr_trabalho });
  }

  createSession(): Observable<{ sessionId: string }> {
    return this.http.post<{ sessionId: string }>(`${this.API_ptai}/create_session`, {});
  }

  resetSession(sessionId: string): Observable<any> {
    const body = { sessionId };
    return this.http.post(`${this.API_ptai}/reset_session`, body);
  }

  // ... dentro da classe ServicoLLMService



salvarMensagem(payload: MensagemPayload): Observable<any> {
  // Ajuste a URL conforme sua configuração
  const url = `${this.API_ptai}/msgchatdest/`;
  return this.http.post<any>(url, payload).pipe(
    catchError((error) => {
      console.error('Erro ao salvar mensagem:', error);
      // Retornar um observable completado em erro não precisa interromper a UI
      return of(null);
    })
  );
}


salvarChatGeral(payload: MensagemPayloadGeral): Observable<any> {
  // Ajuste a URL conforme sua configuração
  const url = `${this.API_ptai}/msgchatgeral/`;
  return this.http.post<any>(url, payload).pipe(
    catchError((error) => {
      console.error('Erro ao salvar mensagem:', error);
      // Retornar um observable completado em erro não precisa interromper a UI
      return of(null);
    })
  );
}

salvarFeedback(payload: FeedbackPayload): Observable<any> {
  const url = `${this.API_ptai}/feedback`;  // Ajuste conforme necessário
  return this.http.post<any>(url, payload).pipe(
    catchError((error) => {
      console.error('Erro ao enviar feedback:', error);
      return throwError(() => error);
    })
  );
}

servicosAgentes(payload: { [key: string]: string }): Observable<any> {
  const url = `${this.API_ptai}/agentesllm/`; // Endpoint no FastAPI
  return this.http.post<any>(url, payload).pipe(
    catchError((error) => {
      console.error('Erro ao enviar dados dinâmicos:', error);
      return throwError(() => new Error('Erro ao enviar dados dinâmicos.'));
    })
  );
}


trbpln(rota: any, json: any): Observable<any[]> {
  return this.http.post<any[]>(`${this.API_ptaiDocker}/${rota}/`, json);
}

getAtb(rota: any, json: any): Observable<any[]> {
  return this.http.post<any[]>(`${this.API_ptaiDocker}/${rota}/`, json);
}

getPDF(rota: any): Observable<any> {
  return this.http.get(`${this.API_ptaiDocker}/${rota}/`, { responseType: 'blob' });
}

uploadDocumento(rota: string, file: File, nome: string): Observable<any> {
  const formData = new FormData();
  formData.append('file', file);

  const headers = new HttpHeaders({
    'enctype': 'multipart/form-data' // Adicione o cabeçalho de Content-Type
  });
    const url = `${this.API_ptaiDocker}/${rota}/?nome=${nome}`;
  return this.http.post<any>(url, formData, { headers, reportProgress: true, observe: 'events' });
}

uploadRelatorioRCM(
  file: File,
  nome: string,
  data: string,
  constatacoes: string,
  recomendacoes: string
): Observable<any> {
  const formData = new FormData();
  formData.append('file', file);
  formData.append('nome', nome);
  formData.append('data', data);
  formData.append('constatacoes', constatacoes);
  formData.append('recomendacoes', recomendacoes);

  // Ajuste a URL para o endpoint que criamos no FastAPI:
  // /apiptai/rcmkpmg
  const url = `${this.API_ptai}/rcmkpmg`;

  return this.http.post<any>(url, formData, {
    reportProgress: true,
    observe: 'events', // se quiser acompanhar progresso
  }).pipe(
    catchError((error) => {
      console.error('Erro ao enviar relatório RCM:', error);
      return throwError(() => error);
    })
  );
}

uploadExcelMultiplosPdfs(excel: File, pdfs: File[]): Observable<any> {
  const formData = new FormData();
  // Adiciona o arquivo Excel
  formData.append('file_excel', excel);

  // Adiciona cada PDF com um nome único
  pdfs.forEach((pdf, index) => {
    formData.append(`file_pdf_${index}`, pdf, pdf.name);
  });

  // Defina a rota de destino
  const url = `${this.API_ptai}/upload-rcm-excel-multiplos`;

  return this.http.post<any>(url, formData).pipe(
    catchError((error) => {
      console.error('Erro ao enviar Excel + múltiplos PDFs:', error);
      return throwError(() => error);
    })
  );
}



listarRelatoriosRcm(): Observable<RcmRelatorio[]> {
  const url = `${this.API_ptai}/listar_rcm_relatorios`;
  return this.http.get<RcmRelatorio[]>(url).pipe(
    catchError((error) => {
      console.error('Erro ao listar rcm_relatorios:', error);
      return throwError(() => error);
    })
  );
}



}


<p-toast></p-toast>

<div style="max-width: 1200px; margin: auto; font-family: Arial, sans-serif;">
  <h2 style="text-align: center; margin-bottom: 1rem;">Upload Recomendações KPMG</h2>

  <!-- Componente Steps para indicar o fluxo -->
  <p-steps [model]="steps" [activeIndex]="activeStep" [readonly]="true" [ngStyle]="{'margin-bottom': '1rem'}"></p-steps>

  <!-- Passo 1: Excel KPMG -->
  <div style="border: 1px solid #ccc; padding: 1rem; border-radius: 5px; margin-bottom: 1rem;">
    <h3 style="margin-bottom: .5rem;">Passo 1: Excel KPMG</h3>
    <p-fileUpload
      #excelUploader
      name="excelFile"
      accept=".xls,.xlsx"
      customUpload="true"
      [auto]="true"
      [showUploadButton]="false"
      [showCancelButton]="false"
      (onSelect)="onSelectExcel($event)"
      (onClear)="onClearExcel()"
    >
    </p-fileUpload>
    <div *ngIf="excelFile" style="margin-top: 0.5rem;">
      <small>Arquivo Selecionado: <strong>{{ excelFile.name }}</strong></small>
    </div>
  </div>

  <!-- Passo 2: Selecione os relatórios (PDFs) -->
  <div *ngIf="excelFile" style="border: 1px solid #ccc; padding: 1rem; border-radius: 5px; margin-bottom: 1rem;">
    <h3 style="margin-bottom: .5rem;">Passo 2: Selecione os relatórios</h3>
    <p-fileUpload
      #pdfUploader
      name="pdfFiles"
      accept=".pdf"
      customUpload="true"
      [auto]="true"
      [multiple]="true"
      [showUploadButton]="false"
      [showCancelButton]="false"
      (onSelect)="onSelectPDF($event)"
      (onClear)="onClearPDF()"
    >
    </p-fileUpload>
    <div *ngIf="pdfFiles.length" style="margin-top: 0.5rem;">
      <small>Arquivos Selecionados: <strong>{{ pdfFilesNames }}</strong></small>
    </div>
  </div>

  <!-- Passo 3: Botão final -->
  <div *ngIf="excelFile && pdfFiles.length >= relatoriosExcel.length" style="text-align: center; margin-bottom: 1rem;">
    <button pButton type="button" label="Upload Recomendações KPMG" style="font-size: 0.8rem; padding: .5rem 1rem;" (click)="enviarArquivosExcel()"></button>
  </div>

  <!-- Exibe os nomes dos arquivos enviados após o envio -->
  <div *ngIf="lastUploadedExcel || lastUploadedPdfs.length" style="margin-top: 1rem; border-top: 1px solid #ccc; padding-top: 1rem;">
    <h3 style="text-align: center;">Arquivos Enviados:</h3>
    <p *ngIf="lastUploadedExcel" style="text-align: center;"><strong>Excel:</strong> {{ lastUploadedExcel }}</p>
    <div *ngIf="lastUploadedPdfs.length">
      <p style="text-align: center;"><strong>PDFs:</strong></p>
      <ul style="list-style: none; padding: 0; text-align: center;">
        <li *ngFor="let pdfName of lastUploadedPdfs" style="display: inline-block; margin: 0 0.5rem;">
          {{ pdfName }}
        </li>
      </ul>
    </div>
  </div>
</div>

<!-- Tabela de registros (p-table) -->
<div class="card" style="max-width: 800px; margin: 2rem auto; font-family: Arial, sans-serif;">
  <h2 style="text-align: center;">Tabela de Relatórios RCM</h2>

  <!-- Filtro global -->
  <div style="text-align:right; margin-bottom:1rem;">
    <span class="p-input-icon-left">
      <i class="pi pi-search"></i>
      <input type="text" pInputText (input)="dt.filterGlobal($any($event.target).value, 'contains')" placeholder="Filtro global..." style="width: 200px;" />
    </span>
  </div>

  <p-table
    #dt
    [value]="rcmRelatorios"
    [paginator]="true"
    [rows]="5"
    [globalFilterFields]="['relatorio','data_emissao','constatacoes','recomendacoes']"
    sortMode="multiple"
    [responsiveLayout]="'scroll'"
  >
    <ng-template pTemplate="header">
      <tr>
        <th pSortableColumn="relatorio">
          Relatório
          <p-sortIcon field="relatorio"></p-sortIcon>
        </th>
        <th pSortableColumn="data_emissao">
          Data Emissão
          <p-sortIcon field="data_emissao"></p-sortIcon>
        </th>
        <th pSortableColumn="constatacoes">
          Constatações
          <p-sortIcon field="constatacoes"></p-sortIcon>
        </th>
        <th pSortableColumn="recomendacoes">
          Recomendações
          <p-sortIcon field="recomendacoes"></p-sortIcon>
        </th>
      </tr>
    </ng-template>

    <ng-template pTemplate="body" let-rel>
      <tr>
        <td>{{ rel.relatorio }}</td>
        <td>{{ rel.data_emissao }}</td>
        <td>{{ rel.constatacoes }}</td>
        <td>{{ rel.recomendacoes }}</td>
      </tr>
    </ng-template>
  </p-table>
</div>

import { Component, ViewChild, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FileUpload, FileUploadModule } from 'primeng/fileupload';
import { ButtonModule } from 'primeng/button';
import { MessageService, MenuItem } from 'primeng/api';
import { ToastModule } from 'primeng/toast';
import { TableModule } from 'primeng/table';
import { StepsModule } from 'primeng/steps';
import * as XLSX from 'xlsx';
import { ServicoLLMService } from '../servico-llm.service';

export interface RcmRelatorio {
  id: number;
  relatorio: string;
  data_emissao: string | null;
  constatacoes: string;
  recomendacoes: string;
}

@Component({
  selector: 'app-rcmexcel',
  standalone: true,
  imports: [
    CommonModule,
    FileUploadModule,
    ButtonModule,
    ToastModule,
    TableModule,
    StepsModule
  ],
  providers: [ServicoLLMService, MessageService],
  templateUrl: './rcmexcel.component.html',
  styleUrls: ['./rcmexcel.component.css']
})
export class RcmexcelComponent implements OnInit {
  excelFile: File | null = null;
  pdfFiles: File[] = [];
  relatoriosExcel: string[] = [];
  rcmRelatorios: RcmRelatorio[] = [];

  @ViewChild('excelUploader') excelUploader!: FileUpload;
  @ViewChild('pdfUploader') pdfUploader!: FileUpload;

  lastUploadedExcel: string | null = null;
  lastUploadedPdfs: string[] = [];

  steps: MenuItem[] = [];
  activeStep: number = 0;

  colunasObrigatorias = [
    'RELATORIO',
    'DATA_EMISSAO',
    'CONSTATACAO',
    'EVIDENCIAS',
    'RECOMENDACAO',
    'INSTITUICAO_RESPONSAVEL',
    'PREFIXO_RESPONSAVEL',
    'INSTITUICAO_ASSUNTO_ELBB',
    'PREVISAO_IMPLEMENTACAO',
    'MATRICULA_DO_GESTOR_RESPONSAVEL'
  ];

  constructor(
    private messageService: MessageService,
    private servicoLLM: ServicoLLMService
  ) {}

  ngOnInit() {
    this.steps = [
      { label: 'Excel KPMG' },
      { label: 'Selecione os Relatórios' },
      { label: 'Upload Recomendações KPMG' }
    ];
    this.getRmcKpmg();
  }

  get pdfFilesNames(): string {
    return this.pdfFiles.map(f => f.name).join(', ');
  }

  onSelectExcel(event: any) {
    if (event.files && event.files.length) {
      const file = event.files[0];
      this.excelFile = file;
      this.lerExcel(file);
      this.activeStep = 1;
    }
  }

  onClearExcel() {
    this.excelFile = null;
    this.relatoriosExcel = [];
  }

  onSelectPDF(event: any) {
    this.pdfFiles = [...this.pdfFiles, ...event.files];
    console.log('PDFs selecionados:', this.pdfFiles.map(f => f.name));
    if (this.pdfFiles.length >= this.relatoriosExcel.length) {
      this.activeStep = 2;
    }
  }

  onClearPDF() {
    this.pdfFiles = [];
  }

  lerExcel(file: File) {
    const reader = new FileReader();
    reader.onload = (e: any) => {
      const data = new Uint8Array(e.target.result);
      const workbook = XLSX.read(data, { type: 'array' });
      const sheetName = workbook.SheetNames[0];
      const worksheet = workbook.Sheets[sheetName];
      const jsonData: any[] = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
      if (!jsonData || !jsonData.length) {
        this.messageService.add({
          severity: 'warn',
          summary: 'Planilha vazia',
          detail: 'Não há dados.'
        });
        return;
      }
      const cabecalho: string[] = jsonData[0].map((val: any) => val?.toString().trim());
      for (const col of this.colunasObrigatorias) {
        if (!cabecalho.includes(col)) {
          this.messageService.add({
            severity: 'error',
            summary: 'Coluna faltando',
            detail: `Coluna "${col}" não encontrada na planilha.`
          });
          this.excelFile = null;
          return;
        }
      }
      const dataObjects = XLSX.utils.sheet_to_json(worksheet, {
        defval: '',
        header: cabecalho,
        range: 1
      });
      const relSet = new Set<string>();
      (dataObjects as any[]).forEach(row => {
        if (row['RELATORIO']) {
          relSet.add(row['RELATORIO'].toString().trim());
        }
      });
      this.relatoriosExcel = Array.from(relSet);
      if (this.relatoriosExcel.length > 1) {
        this.messageService.add({
          severity: 'warn',
          summary: 'Vários RELATORIO',
          detail: `Planilha tem ${this.relatoriosExcel.length} valores distintos.`
        });
      }
      console.log('Relatórios Excel:', this.relatoriosExcel);
    };
    reader.readAsArrayBuffer(file);
  }

  enviarArquivosExcel() {
    if (!this.excelFile) {
      this.messageService.add({
        severity: 'warn',
        summary: 'Aviso',
        detail: 'Selecione a planilha Excel.'
      });
      return;
    }
    if (!this.pdfFiles.length) {
      this.messageService.add({
        severity: 'warn',
        summary: 'Aviso',
        detail: 'Selecione os PDFs.'
      });
      return;
    }
    if (this.pdfFiles.length < this.relatoriosExcel.length) {
      this.messageService.add({
        severity: 'error',
        summary: 'Faltam PDFs',
        detail: `Você tem ${this.relatoriosExcel.length} relatórios distintos, mas apenas ${this.pdfFiles.length} PDFs.`
      });
      return;
    }
    for (const relatorio of this.relatoriosExcel) {
      const pdfEncontrado = this.pdfFiles.some(pdf => {
        const nameNoExt = pdf.name.replace('.pdf', '').trim();
        return nameNoExt === relatorio;
      });
      if (!pdfEncontrado) {
        this.messageService.add({
          severity: 'error',
          summary: 'Nome divergente',
          detail: `Relatório "${relatorio}" não tem PDF correspondente.`
        });
        return;
      }
    }
    this.servicoLLM.uploadExcelMultiplosPdfs(this.excelFile, this.pdfFiles)
      .subscribe({
        next: (res) => {
          console.log('Resposta do backend:', res);
          if (this.excelFile) {
            this.lastUploadedExcel = this.excelFile.name;
          }
          this.lastUploadedPdfs = this.pdfFiles.map(pdf => pdf.name);
          this.excelFile = null;
          this.pdfFiles = [];
          this.relatoriosExcel = [];
          this.excelUploader.clear();
          this.pdfUploader.clear();
          this.messageService.add({
            severity: 'success',
            summary: 'Sucesso',
            detail: 'Excel e PDFs enviados com sucesso!'
          });
          this.getRmcKpmg();
        },
        error: (err: any) => {
          console.error('Erro ao enviar Excel+PDFs:', err);
          this.messageService.add({
            severity: 'error',
            summary: 'Erro',
            detail: err.error?.detail || err.message || 'Falha no upload.'
          });
        }
      });
  }

  getRmcKpmg() {
    this.servicoLLM.listarRelatoriosRcm().subscribe({
      next: (lista) => {
        this.rcmRelatorios = lista.map(item => ({
          ...item,
          relatorio: item.nome
        }));
      },
      error: (err) => {
        console.error('Erro ao buscar relatórios RCM:', err);
      }
    });
  }
}
import { Routes } from '@angular/router';
import { ChatComponent } from './chat/chat.component';
import { ChatDetalheComponent } from './chat-detalhe/chat-detalhe.component';
import { authGuard } from './auth.guard';
import { AcessoNegadoComponent } from './acesso-negado/acesso-negado.component';
import { ChatgeralComponent } from './chatgeral/chatgeral.component';
import { chatgeralMatcher } from './chatgeral.matcher';
import { AtbComponent } from './atb/atb.component';
import { RcmComponent } from './rcm/rcm.component'; // <- Importando o standalone
import { RcmexcelComponent } from './rcmexcel/rcmexcel.component';

export const routes: Routes = [
  {
    path: '',
    redirectTo: '/chat',
    pathMatch: 'full',
  },
  {
    path: 'chat',
    component: ChatComponent,
    canActivate: [authGuard],
  },
  {
    path: 'atb',
    component: AtbComponent,
    canActivate: [authGuard],
  },
  {
    path: 'chatdetalhe/:nr_trabalho',
    component: ChatDetalheComponent,
    canActivate: [authGuard],
    data: { renderMode: 'lazy' },
  },
  {
    matcher: chatgeralMatcher,
    component: ChatgeralComponent,
    canActivate: [authGuard],
    data: { renderMode: 'lazy' },
  },
  {
    path: 'rcm',
    component: RcmComponent,
    canActivate: [authGuard],
  },
  {
    path: 'rcmexel',
    component: RcmexcelComponent,
    canActivate: [authGuard],
  },
  {
    path: 'acesso-negado',
    component: AcessoNegadoComponent,
  },
  {
    path: '**',
    redirectTo: '/chat',
  },
];


from fastapi import APIRouter, File, UploadFile, responses, HTTPException, Form, Request
from fastapi.responses import HTMLResponse
from fastapi.staticfiles import StaticFiles

from fastapi.responses import StreamingResponse, Response
from fastapi.responses import FileResponse

from fastapi.responses import FileResponse


from app.infra.sqlalchemy.dao.queries_rcm import tcu_upate_insert
from app.infra.sqlalchemy.config.conexoes import *
from app.infra.sqlalchemy.config.database_pool import pool, execute_query

from io import BytesIO
import re
import fitz  # PyMuPDF
import uuid  # Importe o módulo uuid aqui
import PyPDF2

from datetime import datetime, timedelta
from hashlib import sha256

import pdfkit as pdf

from pyvirtualdisplay import Display



import pandas as pd
import openpyxl
from openpyxl import load_workbook


from openpyxl.styles import colors, PatternFill

from openpyxl.utils import get_column_letter
from openpyxl.drawing.image import Image as ExcelImage

import xlsxwriter

from matplotlib.colors import rgb2hex
import matplotlib.pyplot as plt
from PIL import Image as PILImage
from matplotlib.backends.backend_agg import FigureCanvasAgg as FigureCanvas

from PIL import Image, ImageDraw, ImageFont, ImageColor
import io

from datetime import datetime

import shutil
from os import getcwd

from app.infra.sqlalchemy.dao.queries_geral import inserir_relatorio_rcm, inserir_linha_rcm
from fastapi.responses import StreamingResponse, Response
import io

from io import BytesIO
from typing import Dict, List

router = APIRouter()

@router.post("/apiptai/rcmkpmg")
async def salvar_relatorio_rcm(
    nome: str = Form(...),
    data: str = Form(...),
    constatacoes: str = Form(...),
    recomendacoes: str = Form(...),
    file: UploadFile = File(...)
):
    # Lê o conteúdo binário do PDF
    pdf_bytes = await file.read()

    # Chama a função para inserir no PostgreSQL
    try:
        novo_id = await inserir_relatorio_rcm(nome, data, constatacoes, recomendacoes, pdf_bytes)
        return {
            "status": "ok",
            "id_inserido": novo_id,
            "mensagem": "Relatório RCM salvo com sucesso no banco."
        }
    except Exception as e:
        return {
            "status": "erro",
            "detalhe": str(e)
        }
        
@router.get("/apiptai/listar_rcm_relatorios")
async def listar_rcm_relatorios():
    query = """
    SELECT
      id,
      relatorio,               -- em vez de "nome"
      data_emissao,
      constatacoes,
      recomendacao AS recomendacoes  -- se quiser renomear no SELECT
    FROM rcm.rcm_relatorios
    ORDER BY id ASC;
    """
    registros = await execute_query(query)
    return registros

@router.get("/apiptai/rcmkpmg/{relatorio_id}")
async def get_relatorio_rcm(relatorio_id: int):
    query = """
    SELECT pdf_file, nome, data, constatacoes, recomendacoes
    FROM rcm.rcm_relatorios
    WHERE id = $1;
    """
    resultado = await execute_query(query, relatorio_id, return_one=True)
    if not resultado:
        return {"erro": "Relatório não encontrado"}
    
    pdf_bytes = resultado['pdf_file']  # isto deve ser um campo BYTEA (bytes)

    # Abordagem 1: Retornar de uma vez só usando Response
    return Response(content=pdf_bytes, media_type="application/pdf")

    # Abordagem 2: Usar StreamingResponse
    # return StreamingResponse(
    #     io.BytesIO(pdf_bytes),
    #     media_type="application/pdf"
    # )
    

@router.post("/apiptai/upload-rcm-excel-multiplos")
async def upload_rcm_excel_multiplos(request: Request):
    """
    Recebe 1 Excel (file_excel) + PDFs (file_pdf_0, file_pdf_1, ...).
    Para cada DATA_EMISSAO encontrada na planilha:
      - Apaga do BD as linhas com data_emissao = X
      - Insere todas as linhas correspondentes com os dados do Excel
    """
    form = await request.form()

    # Pega o Excel
    file_excel: UploadFile = form.get("file_excel")
    if not file_excel:
        raise HTTPException(status_code=400, detail="Arquivo Excel (file_excel) é obrigatório.")
    if not (file_excel.filename.lower().endswith(".xlsx") or file_excel.filename.lower().endswith(".xls")):
        raise HTTPException(status_code=400, detail="O arquivo Excel deve ser .xlsx ou .xls")

    excel_bytes = await file_excel.read()
    try:
        df = pd.read_excel(BytesIO(excel_bytes))
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Erro ao ler Excel: {str(e)}")

    # Valida colunas obrigatórias
    colunas_obrigatorias = [
        "RELATORIO", "DATA_EMISSAO", "CONSTATACAO", "EVIDENCIAS", "RECOMENDACAO",
        "INSTITUICAO_RESPONSAVEL", "PREFIXO_RESPONSAVEL", "INSTITUICAO_ASSUNTO_ELBB",
        "PREVISAO_IMPLEMENTACAO", "MATRICULA_DO_GESTOR_RESPONSAVEL"
    ]
    for col in colunas_obrigatorias:
        if col not in df.columns:
            raise HTTPException(status_code=400, detail=f"Coluna '{col}' não encontrada no Excel.")

    # PDFs
    pdf_keys = [key for key in form.keys() if key.startswith("file_pdf_")]
    if len(pdf_keys) == 0:
        raise HTTPException(status_code=400, detail="Nenhum PDF enviado (file_pdf_0, file_pdf_1, ...).")

    pdf_dict: Dict[str, bytes] = {}
    for key in pdf_keys:
        pdf_upload: UploadFile = form[key]
        if not pdf_upload.filename.lower().endswith(".pdf"):
            raise HTTPException(status_code=400, detail=f"O arquivo {pdf_upload.filename} não é PDF.")
        pdf_name_no_ext = pdf_upload.filename.replace(".pdf", "").strip()
        pdf_content = await pdf_upload.read()
        pdf_dict[pdf_name_no_ext] = pdf_content

    # Agrupa o DataFrame pela coluna DATA_EMISSAO
    df_records = df.to_dict("records")
    grouped: Dict[str, List[Dict]] = {}
    for row in df_records:
        data_emissao = str(row["DATA_EMISSAO"]).strip()
        if data_emissao not in grouped:
            grouped[data_emissao] = []
        grouped[data_emissao].append(row)

    ids_inseridos_total = []
    for data_emissao_val, rows in grouped.items():
        # Apaga registros com a mesma data_emissao
        delete_query = "DELETE FROM rcm.rcm_relatorios WHERE data_emissao = $1"
        await execute_query(delete_query, data_emissao_val)

        # Insere cada linha para essa data_emissao
        for row in rows:
            relatorio_val = str(row["RELATORIO"]).strip()
            constatacoes = str(row["CONSTATACAO"]).strip()
            evidencias = str(row["EVIDENCIAS"]).strip()
            recomendacao = str(row["RECOMENDACAO"]).strip()
            instituicao_responsavel = str(row["INSTITUICAO_RESPONSAVEL"]).strip()
            prefixo_responsavel = str(row["PREFIXO_RESPONSAVEL"]).strip()
            instituicao_assunto_elbb = str(row["INSTITUICAO_ASSUNTO_ELBB"]).strip()
            previsao_implementacao = str(row["PREVISAO_IMPLEMENTACAO"]).strip()
            matricula_do_gestor_responsavel = str(row["MATRICULA_DO_GESTOR_RESPONSAVEL"]).strip()

            pdf_bytes = pdf_dict.get(relatorio_val)
            if not pdf_bytes:
                raise HTTPException(
                    status_code=400,
                    detail=f"Falta PDF '{relatorio_val}.pdf' para o relatório '{relatorio_val}'."
                )

            novo_id = await inserir_linha_rcm(
                relatorio=relatorio_val,
                data_emissao=data_emissao_val,
                constatacoes=constatacoes,
                evidencias=evidencias,
                recomendacao=recomendacao,
                instituicao_responsavel=instituicao_responsavel,
                prefixo_responsavel=prefixo_responsavel,
                instituicao_assunto_elbb=instituicao_assunto_elbb,
                previsao_implementacao=previsao_implementacao,
                matricula_do_gestor_responsavel=matricula_do_gestor_responsavel,
                pdf_blob=pdf_bytes
            )
            if novo_id:
                ids_inseridos_total.append(novo_id)

    return {
        "status": "ok",
        "mensagem": "Upload múltiplo concluído com sobrescrita por data_emissao.",
        "datas_processadas": list(grouped.keys()),
        "ids_inseridos": ids_inseridos_total
    }


import json
from typing import List, Dict
from app.infra.sqlalchemy.config.database_pool import pool, execute_query, execute_query2, execute_query3  # Importe o pool de database.py
from app.infra.sqlalchemy.repositorios.aux_txt_rcm import obter_textos
from app.infra.sqlalchemy.dao.apigpt import processar_texto_gpt_rcm_ae
import logging
logger = logging.getLogger(__name__)
import asyncio
from pydantic import BaseModel
from typing import List
from datetime import datetime
from typing import Optional

async def inserir_relatorio_rcm(
    nome: str,
    data_str: str,  # Recebe como string (ex.: '2024-09-20 00:00:00' ou '30-06-2025')
    constatacoes: str,
    recomendacoes: str,
    pdf_blob: bytes
):
    """
    Insere um relatório RCM no schema rcm, armazenando também o PDF como blob (bytea).
    Agora, a coluna 'data' da tabela rcm.rcm_relatorios é do tipo TEXT, não date.
    """

    query = """
    INSERT INTO rcm.rcm_relatorios (nome, data, constatacoes, recomendacoes, pdf_file)
    VALUES ($1, $2, $3, $4, $5)
    RETURNING id;
    """
    # Observe que na coluna 'data' estamos passando $2 (data_str) diretamente,
    # sem TO_DATE ou cast de data.

    result = await execute_query(
        query,
        nome,
        data_str,  # inserido como texto na coluna 'data'
        constatacoes,
        recomendacoes,
        pdf_blob,
        return_one=True
    )

    if result:
        return result.get('id')
    return None

async def inserir_linha_rcm(nome: str,
                            data_emissao: str,
                            constatacoes: str,
                            recomendacoes: str,
                            pdf_blob: bytes):
    """
    Insere 1 linha na tabela rcm.rcm_relatorios,
    armazenando data_emissao como text e pdf_file como blob.
    """
    query = """
    INSERT INTO rcm.rcm_relatorios (
       nome,
       data_emissao,
       constatacoes,
       recomendacoes,
       pdf_file
    ) VALUES ($1, $2, $3, $4, $5)
    RETURNING id;
    """
    result = await execute_query(
        query,
        nome,
        data_emissao,
        constatacoes,
        recomendacoes,
        pdf_blob,
        return_one=True
    )
    if result:
        return result.get("id")
    return None

async def inserir_linha_rcm(
    relatorio: str,
    data_emissao: str,
    constatacoes: str,
    evidencias: str,
    recomendacao: str,
    instituicao_responsavel: str,
    prefixo_responsavel: str,
    instituicao_assunto_elbb: str,
    previsao_implementacao: str,
    matricula_do_gestor_responsavel: str,
    pdf_blob: bytes
):
    """
    Insere uma linha na tabela rcm.rcm_relatorios com todas as colunas.
    """
    query = """
    INSERT INTO rcm.rcm_relatorios (
      relatorio,
      data_emissao,
      constatacoes,
      evidencias,
      recomendacao,
      instituicao_responsavel,
      prefixo_responsavel,
      instituicao_assunto_elbb,
      previsao_implementacao,
      matricula_do_gestor_responsavel,
      pdf_file
    ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
    RETURNING id;
    """
    result = await execute_query(
        query,
        relatorio,
        data_emissao,
        constatacoes,
        evidencias,
        recomendacao,
        instituicao_responsavel,
        prefixo_responsavel,
        instituicao_assunto_elbb,
        previsao_implementacao,
        matricula_do_gestor_responsavel,
        pdf_blob,
        return_one=True
    )
    if result:
        return result.get("id")
    return None

