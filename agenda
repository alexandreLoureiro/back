---------------------------------------------------------------------------
UndefinedFunction                         Traceback (most recent call last)
File ~/anaconda3/lib/python3.9/site-packages/sqlalchemy/engine/base.py:1905, in Connection._execute_context(self, dialect, constructor, statement, parameters, execution_options, *args, **kw)
   1904     if not evt_handled:
-> 1905         self.dialect.do_execute(
   1906             cursor, statement, parameters, context
   1907         )
   1909 if self._has_events or self.engine._has_events:

File ~/anaconda3/lib/python3.9/site-packages/sqlalchemy/engine/default.py:736, in DefaultDialect.do_execute(self, cursor, statement, parameters, context)
    735 def do_execute(self, cursor, statement, parameters, context=None):
--> 736     cursor.execute(statement, parameters)

UndefinedFunction: function pg_catalog.date_part(unknown, text) does not exist
LINE 4:     EXTRACT(year FROM data_emissao) AS ano,
            ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


The above exception was the direct cause of the following exception:

ProgrammingError                          Traceback (most recent call last)
Input In [71], in <cell line: 21>()
      1 base_query = """
      2 
      3 SELECT 
   (...)
     19     END;
     20 """
---> 21 df = pd.read_sql(base_query, engine)

File ~/anaconda3/lib/python3.9/site-packages/pandas/io/sql.py:628, in read_sql(sql, con, index_col, coerce_float, params, parse_dates, columns, chunksize)
    619     return pandas_sql.read_table(
    620         sql,
    621         index_col=index_col,
   (...)
    625         chunksize=chunksize,
    626     )
    627 else:
--> 628     return pandas_sql.read_query(
    629         sql,
    630         index_col=index_col,
    631         params=params,
    632         coerce_float=coerce_float,
    633         parse_dates=parse_dates,
    634         chunksize=chunksize,
    635     )

File ~/anaconda3/lib/python3.9/site-packages/pandas/io/sql.py:1579, in SQLDatabase.read_query(self, sql, index_col, coerce_float, parse_dates, params, chunksize, dtype)
   1531 """
   1532 Read SQL query into a DataFrame.
   1533 
   (...)
   1575 
   1576 """
   1577 args = _convert_params(sql, params)
-> 1579 result = self.execute(*args)
   1580 columns = result.keys()
   1582 if chunksize is not None:

File ~/anaconda3/lib/python3.9/site-packages/pandas/io/sql.py:1424, in SQLDatabase.execute(self, *args, **kwargs)
   1422 def execute(self, *args, **kwargs):
   1423     """Simple passthrough to SQLAlchemy connectable"""
-> 1424     return self.connectable.execution_options().execute(*args, **kwargs)

File <string>:2, in execute(self, statement, *multiparams, **params)

File ~/anaconda3/lib/python3.9/site-packages/sqlalchemy/util/deprecations.py:468, in _decorate_with_warning.<locals>.warned(fn, *args, **kwargs)
    466 if not skip_warning:
    467     _warn_with_version(message, version, wtype, stacklevel=3)
--> 468 return fn(*args, **kwargs)

File ~/anaconda3/lib/python3.9/site-packages/sqlalchemy/engine/base.py:3262, in Engine.execute(self, statement, *multiparams, **params)
   3244 """Executes the given construct and returns a
   3245 :class:`_engine.CursorResult`.
   3246 
   (...)
   3259 
   3260 """
   3261 connection = self.connect(close_with_result=True)
-> 3262 return connection.execute(statement, *multiparams, **params)

File ~/anaconda3/lib/python3.9/site-packages/sqlalchemy/engine/base.py:1370, in Connection.execute(self, statement, *multiparams, **params)
   1361 if isinstance(statement, util.string_types):
   1362     util.warn_deprecated_20(
   1363         "Passing a string to Connection.execute() is "
   1364         "deprecated and will be removed in version 2.0.  Use the "
   (...)
   1367         "driver-level SQL string."
   1368     )
-> 1370     return self._exec_driver_sql(
   1371         statement,
   1372         multiparams,
   1373         params,
   1374         _EMPTY_EXECUTION_OPTS,
   1375         future=False,
   1376     )
   1378 try:
   1379     meth = statement._execute_on_connection

File ~/anaconda3/lib/python3.9/site-packages/sqlalchemy/engine/base.py:1674, in Connection._exec_driver_sql(self, statement, multiparams, params, execution_options, future)
   1664         (
   1665             statement,
   1666             distilled_params,
   (...)
   1670             statement, distilled_parameters, execution_options
   1671         )
   1673 dialect = self.dialect
-> 1674 ret = self._execute_context(
   1675     dialect,
   1676     dialect.execution_ctx_cls._init_statement,
   1677     statement,
   1678     distilled_parameters,
   1679     execution_options,
   1680     statement,
   1681     distilled_parameters,
   1682 )
   1684 if not future:
   1685     if self._has_events or self.engine._has_events:

File ~/anaconda3/lib/python3.9/site-packages/sqlalchemy/engine/base.py:1948, in Connection._execute_context(self, dialect, constructor, statement, parameters, execution_options, *args, **kw)
   1945             branched.close()
   1947 except BaseException as e:
-> 1948     self._handle_dbapi_exception(
   1949         e, statement, parameters, cursor, context
   1950     )
   1952 return result

File ~/anaconda3/lib/python3.9/site-packages/sqlalchemy/engine/base.py:2129, in Connection._handle_dbapi_exception(self, e, statement, parameters, cursor, context)
   2127     util.raise_(newraise, with_traceback=exc_info[2], from_=e)
   2128 elif should_wrap:
-> 2129     util.raise_(
   2130         sqlalchemy_exception, with_traceback=exc_info[2], from_=e
   2131     )
   2132 else:
   2133     util.raise_(exc_info[1], with_traceback=exc_info[2])

File ~/anaconda3/lib/python3.9/site-packages/sqlalchemy/util/compat.py:211, in raise_(***failed resolving arguments***)
    208     exception.__cause__ = replace_context
    210 try:
--> 211     raise exception
    212 finally:
    213     # credit to
    214     # https://cosmicpercolator.com/2016/01/13/exception-leaks-in-python-2-and-3/
    215     # as the __traceback__ object creates a cycle
    216     del exception, replace_context, from_, with_traceback

File ~/anaconda3/lib/python3.9/site-packages/sqlalchemy/engine/base.py:1905, in Connection._execute_context(self, dialect, constructor, statement, parameters, execution_options, *args, **kw)
   1903                 break
   1904     if not evt_handled:
-> 1905         self.dialect.do_execute(
   1906             cursor, statement, parameters, context
   1907         )
   1909 if self._has_events or self.engine._has_events:
   1910     self.dispatch.after_cursor_execute(
   1911         self,
   1912         cursor,
   (...)
   1916         context.executemany,
   1917     )

File ~/anaconda3/lib/python3.9/site-packages/sqlalchemy/engine/default.py:736, in DefaultDialect.do_execute(self, cursor, statement, parameters, context)
    735 def do_execute(self, cursor, statement, parameters, context=None):
--> 736     cursor.execute(statement, parameters)

ProgrammingError: (psycopg2.errors.UndefinedFunction) function pg_catalog.date_part(unknown, text) does not exist
LINE 4:     EXTRACT(year FROM data_emissao) AS ano,
            ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.

[SQL: 

SELECT 
    EXTRACT(year FROM data_emissao) AS ano,
    CASE 
        WHEN EXTRACT(month FROM data_emissao) <= 6 THEN '1º Semestre'
        ELSE '2º Semestre'
    END AS semestre,
    string_agg('relatorio: ' || relatorio_text_extract, ' ') AS relatorios_periodo
FROM 
    rcm.rcm_kpmg_relatorios
WHERE 
    sumario_executivo_per IS NULL
GROUP BY 
    EXTRACT(year FROM data_emissao),
    CASE 
        WHEN EXTRACT(month FROM data_emissao) <= 6 THEN '1º Semestre'
        ELSE '2º Semestre'
    END;
]
(Background on this error at: https://sqlalche.me/e/14/f405)

SELECT 
    EXTRACT(year FROM data_emissao) AS ano,
    CASE 
        WHEN EXTRACT(month FROM data_emissao) <= 6 THEN '1º Semestre'
        ELSE '2º Semestre'
    END AS semestre,
    string_agg('relatorio: ' || relatorio_text_extract, ' ') AS relatorios_periodo
FROM 
    rcm.rcm_kpmg_relatorios
WHERE 
    sumario_executivo_per IS NULL
GROUP BY 
    EXTRACT(year FROM data_emissao),
    CASE 
        WHEN EXTRACT(month FROM data_emissao) <= 6 THEN '1º Semestre'
        ELSE '2º Semestre'
    END;


SELECT 
    data_emissao,
    string_agg('relatorio: ' || relatorio_text_extract, ' ') AS relatorios_periodo
FROM 
    rcm.rcm_kpmg_relatorios
WHERE 
    sumario_executivo_per IS NULL
GROUP BY 
    data_emissao;

Você receberá um agrupamento de relatórios de auditoria externa consolidados por data de emissão no campo {relatorios_periodo}. Sua tarefa é gerar dois atributos, utilizando formatação innerHTML com tags HTML, conforme descrito abaixo:

1. **sumario_executivo_per**:
   - Crie um sumário executivo curto e profissional, composto por poucas frases, que destaque os principais pontos dos relatórios consolidados, enfatizando os riscos relevantes e achados significativos, que realmente merecem ser citados para a alta administração do banco.
   - Utilize elementos visuais (como <strong> para negrito, ícones, etc.) para evidenciar pontos importantes.
   - Após essas frases, em uma nova linha, adicione uma frase curta em itálico (<em>) contendo parte do texto original da extração para facilitar a consulta do auditor.

2. **racional_sumario_per**:
   - Forneça uma explicação sucinta do raciocínio adotado para a seleção dos pontos destacados no sumário, contextualizando os critérios utilizados e a relevância dos pontos escolhidos.

Retorne o resultado em formato JSON puro, sem qualquer marcação extra, conforme o exemplo abaixo:

{
  "sumario_executivo_per": "<p><strong>Principal ponto:</strong> [Texto resumido com destaques e ícones se aplicável].<br><em>[Texto original resumido da extração]</em></p>",
  "racional_sumario_per": "[Explicação do raciocínio adotado para a elaboração do sumário]"
}


# Exemplo: df_gpt_period deve possuir as colunas: data_emissao, sumario_executivo_per, racional_sumario_per

update_query = text(f"""
    UPDATE rcm.rcm_kpmg_relatorios
    SET 
        sumario_executivo_per = :sumario_executivo_per,
        racional_sumario_per = :racional_sumario_per
    WHERE data_emissao = :data_emissao
""")

with engine.begin() as connection:
    for index, row in df_gpt_period.iterrows():
        params = {
            'sumario_executivo_per': row['sumario_executivo_per'],
            'racional_sumario_per': row['racional_sumario_per'],
            'data_emissao': row['data_emissao']
        }
        connection.execute(update_query, **params)
        print(f"Registro atualizado para data_emissao: {row['data_emissao']}")

print("Atualização dos relatórios por período concluída.")







# 1. Extrair dados agregados da tabela exterior.ptai_trabalhos_1, normalizando nm_rsco_objt
base_query = """
SELECT distinct relatorio, data_emissao, relatorio_text_extract
FROM rcm.rcm_kpmg_relatorios where sumario_executivo_rel is null;
"""
df = pd.read_sql(base_query, engine)

# Query de update utilizando as colunas relatorio e data_emissao como condição
update_query = text(f"""
    UPDATE {schema_name}.{table_name}
    SET 
        sumario_executivo = :sumario_executivo,
        racional_sumario = :racional_sumario
    WHERE relatorio = :relatorio
      AND data_emissao = :data_emissao
""")

# Executa a atualização para cada registro presente no dataframe
with engine.begin() as connection:
    for index, row in df_gpt.iterrows():
        params = {
            'sumario_executivo': row['sumario_executivo'],
            'racional_sumario': row['racional_sumario'],
            'relatorio': row['relatorio'],
            'data_emissao': row['data_emissao']
        }
        connection.execute(update_query, **params)
        print(f"Registro atualizado para relatorio: {row['relatorio']} e data_emissao: {row['data_emissao']}.")

print("Atualização concluída.")


Você receberá um relatório de auditoria externa completo no campo {relatorio}. Sua tarefa é gerar dois atributos, utilizando formatação innerHTML com tags HTML, da seguinte forma:

1. **sumario_executivo**:  
   - Crie um sumário executivo curto, composto por poucas frases, que destaque os principais pontos do relatório, com ênfase nos riscos relevantes e achados significativos que realmente valem a pena ser citados para a alta administração do banco.  
   - O texto deve ser profissional, como um resumo de auditoria, podendo utilizar elementos como **negrito** para destacar pontos importantes, ícones e outros elementos visuais que façam sentido para a apresentação.  
   - Após essa frase ou conjunto de frases, em uma nova linha, adicione, em itálico, uma frase curta contendo o texto original da extração (ou parte dele) para facilitar a consulta pelo auditor.

2. **racional_sumario**:  
   - Forneça uma explicação sucinta do raciocínio adotado para a seleção dos pontos destacados no sumário. Essa explicação deve contextualizar os critérios utilizados e ajudar o auditor a entender a relevância dos pontos escolhidos.

Retorne o resultado em formato JSON puro, sem qualquer marcação extra, seguindo o exemplo abaixo:

{
  "sumario_executivo": "<p><strong>Principal ponto:</strong> [Texto resumido com destaques e ícones se aplicável].<br><em>[Texto original resumido da extração]</em></p>",
  "racional_sumario": "[Explicação do raciocínio adotado para a elaboração do sumário]"
}



import pandas as pd
from sqlalchemy import create_engine, inspect, text

# Supondo que a função 'postgres()' já esteja definida e retorne (conn, engine)
conn, engine = postgres()

# Nome da tabela e do schema
table_name = "rcm_kpmg_relatorios"
schema_name = "rcm"

# Lista de colunas a serem criadas (coluna: tipo de dados)
columns_to_add = {
    'achou_constatacao': 'TEXT',
    'achou_recomendacao': 'TEXT',
    'dica_localizar_constatacao': 'TEXT',
    'dica_localizar_recomendacao': 'TEXT',
    'conf_implementacao': 'TEXT',
    'racional': 'TEXT',
    'resumo_constatacao': 'TEXT',
    'resumo_recomendacao': 'TEXT'
}

# Cria um inspetor para verificar as colunas existentes
inspector = inspect(engine)
existing_columns = [col['name'] for col in inspector.get_columns(table_name, schema=schema_name)]

# Abre uma conexão de transação para realizar os ALTER TABLE se necessário
with engine.begin() as connection:
    for col, data_type in columns_to_add.items():
        if col not in existing_columns:
            alter_sql = f"ALTER TABLE {schema_name}.{table_name} ADD COLUMN {col} {data_type};"
            connection.execute(text(alter_sql))
            print(f"Coluna '{col}' adicionada à tabela {schema_name}.{table_name}.")

# Agora, para cada linha do DataFrame df_gpt, fazemos um UPDATE na tabela
update_query = text(f"""
    UPDATE {schema_name}.{table_name}
    SET 
        achou_constatacao = :achou_constatacao,
        achou_recomendacao = :achou_recomendacao,
        dica_localizar_constatacao = :dica_localizar_constatacao,
        dica_localizar_recomendacao = :dica_localizar_recomendacao,
        conf_implementacao = :conf_implementacao,
        racional = :racional,
        resumo_constatacao = :resumo_constatacao,
        resumo_recomendacao = :resumo_recomendacao
    WHERE id = :id
""")

# Realiza os updates para cada registro baseado na coluna 'id'
with engine.begin() as connection:
    for index, row in df_gpt.iterrows():
        params = {
            'id': row['id'],
            'achou_constatacao': row['achou_constatacao'],
            'achou_recomendacao': row['achou_recomendacao'],
            'dica_localizar_constatacao': row['dica_localizar_constatacao'],
            'dica_localizar_recomendacao': row['dica_localizar_recomendacao'],
            'conf_implementacao': row['conf_implementacao'],
            'racional': row['racional'],
            'resumo_constatacao': row['resumo_constatacao'],
            'resumo_recomendacao': row['resumo_recomendacao']
        }
        connection.execute(update_query, **params)
        print(f"Registro com id {row['id']} atualizado.")

print("Processamento concluído.")



ok, agora tenho esse dataframe:

df_gpt[['id', 'achou_constatacao', 'achou_recomendacao',
       'dica_localizar_constatacao', 'dica_localizar_recomendacao',
       'conf_implementacao', 'racional', 'resumo_constatacao',
       'resumo_recomendacao']].head()

já tenho minha conexao:

conn, engine = postgres()
base_query = """
SELECT id, constatacoes, evidencias, recomendacao, relatorio_text_extract, previsao_implementacao, gpt_id
FROM rcm.rcm_kpmg_relatorios where gpt_id is null;
"""
df = pd.read_sql(base_query, engine)

antes fazia assim: 

df_resultados.to_sql(
                name=table_name,
                con=engine,
                schema=schema_name,
                if_exists='append',  # ou 'append'
                index=False
            )
            logging.info(f"Processamento concluído. {len(resultados)} registros inseridos no banco de dados.")

agora eu que criar se nao exisitr as colunas 'achou_constatacao', 'achou_recomendacao',
       'dica_localizar_constatacao', 'dica_localizar_recomendacao',
       'conf_implementacao', 'racional', 'resumo_constatacao',
       'resumo_recomendacao' em rcm.rcm_kpmg_relatorios e depois 
fazer um update por id dos valores dessas colunas do dataframe na minha tabela postgres
