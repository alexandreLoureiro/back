

Tenho uma aplicação que usa uma chamada api de uma llm que passo em um script que roda em batch dos trabalhos de auditoria, relatório, principais contatações,
evidencias e recomendação, com base nessa informação solicito que gere um destaque de auditoria
 após ele gerar esse destaque salvo em um banco de dados

Depois disso criei uma aplicação usando fastapi e angular, que traz um destaque gerado para determinador trabalho e um chat para que o auditor possa tirar duvidas sobre o destaque e solcitar melhorar,
essa aplicação será desenvolvida por outra equipe agora, preciso documentar para eles pq eles querem usar a api, pode me ajudar?


primeira chamada 

https://mefis.bb.com.br/apiptai/chat_trabalho/ 
passo o numero do trabalho


class ChatTrabalhoRequest(BaseModel):
    nr_trabalho: int
    
@router.post("/apiptai/chat_trabalho/")
async def trabalhoChat(request: ChatTrabalhoRequest):
    nr_trabalho = request.nr_trabalho
    
    result = await chat_trabalho(nr_trabalho)  # Chama a função assíncrona
    return result

async def chat_trabalho(nr_trabalho: int):
    query = f"""
    SELECT DISTINCT  
           nr_trabalho, 
           titulo, 
           nr_trabalho, 
           ano, 
           nm_trab, 
           obj_trab, 
           manchete_html, 
           materia_html, 
           rel_hash, 
           pontos_positivo_html, 
           pontos_aprimorar_html, 
           materialidade_html,
           dt_movimento,
           
           CONCAT(
               'Você é um assistente especializado em auditoria interna. Sua tarefa é analisar as informações fornecidas sobre um ',
               'trabalho de auditoria e gerar um Destaque de Auditoria seguindo as diretrizes estabelecidas. ',
               
               '\\n\\nDefinição de Destaque de Auditoria: ',
               'Um Destaque de Auditoria são informações de valor agregado, relevantes e úteis, descritas sob a forma de pequenas ',
               'manchetes. Eles podem se referir à identificação e mitigação de constatações significativas ou a melhorias de ',
               'processos implementadas pelos gestores. Destinam-se ao Conselho de Administração (CA), Conselho Fiscal (CF), ',
               'Coadutoria (Coaud) e Conselho de Diretoria (CD). Deve apresentar uma visão sistêmica, linguagem jornalística, ',
               'ordem direta, sem tecnicismos, coerência com os eventos de risco avaliados, e alinhamento com a materialidade ',
               'e criticidade das recomendações.',

               '\\n\\nEstrutura dos Dados da Auditoria: ',
               'Os dados fornecidos para análise estão estruturados da seguinte forma:',
               '- [trabalho]: Número do trabalho. ',
               '- [objetivo trabalho]: Objetivo do trabalho. ',
               '- [justificativa trabalho]: Justificativa do trabalho. ',
               '- [eventos de riscos avaliados]: Eventos de riscos avaliados. ',
               '- [relatorio auditoria]: Relatório de auditoria. ',
               '- [principal constatação no relatorio]: Principal constatação do relatório. ',
               '- [ocorrência e evidencia de achados de auditoria]: Ocorrências e evidências de achados de auditoria. ',
               '- [recomendações]: Recomendações.',

               '\\n\\nCritérios para Identificar Relevância: ',
               '- Eventos de Risco Críticos: Priorizar eventos avaliados com notas 4 e 5 em [eventos de riscos avaliados]. ',
               '- Recomendações Relevantes: Priorizar recomendações com criticidade \"A\" e \"B\" em [recomendações]. ',
               '- Ocorrências e Evidências Significativas: Identificar as evidências e ocorrências mais relevantes em [ocorrência e evidencia de achados de auditoria]. ',

               '\\n\\nDados da Auditoria: ',
               'trabalho: ', nr_trabalho,
               ' | objetivo trabalho: ', obj_trab, 
               ' | eventos de riscos avaliados: ', evento_rsco_avaliado,
               ' | relatorio auditoria: ', tx_rel_atvd,  
               ' | principal constatação no relatorio: ', tx_constatacao, 
               ' | recomendações: ', rcm_concat,

               '\\n\\nA partir de agora, você participará de um chat em que o auditor poderá fazer perguntas sobre o trabalho de auditoria, incluindo detalhes como recomendações, principais constatações do relatório e pontos de atenção. ',
               'É fundamental que suas respostas sejam consistentes, diretas e baseadas nos dados fornecidos. ',
               'Evite pedidos de desculpas ou tentativas de adequação desnecessárias. ',
               'Caso seja questionado por que um ponto específico não foi incluído como recomendação ou destaque, explique o raciocínio por trás da decisão com base nos critérios de relevância e criticidade. ',
               'Sempre que possível, reforce a lógica usada para gerar os destaques e justifique sua análise. ',
               
               '\\n\\n**Importante**: ',
               '- Suas respostas devem ter no máximo ~800 caracteres, em até dois parágrafos. ',
               '- Se a pergunta ultrapassar o escopo dos dados fornecidos ou não tiver relação alguma com auditoria, você deve se recusar a responder ou informar gentilmente que não pode ajudar nesse tema. ',
               '- Mantenha-se dentro do contexto do trabalho de auditoria em questão. ',
               '- Não use informações que não estejam no texto fornecido ou que não sejam relacionadas diretamente à auditoria.'
           ) AS role_user,

           CONCAT(
               'Segue minha análise: ',
               ' pontos_positivo: ', pontos_positivo, 
               ' pontos_aprimorar: ', pontos_aprimorar, 
               ' materialidade: ', materialidade
           ) AS role_assistant

    FROM destaques.gpt_destaques
    WHERE nr_trabalho = {nr_trabalho};
    """
    return await execute_query(query)

dentre os atributos do objeto json que retorna, traz o role_user e role_assistant que é a contextualização innicial

Cria uma nova sessão ao carregar o componente no angular
@router.post("/apiptai/create_session", response_model=SessionResponse)
def create_session():
    """
    Gera um sessionId único e inicializa a sessão no servidor.
    """
    session_id = str(uuid.uuid4())  # Gera um UUID único
    sessions[session_id] = []  # Inicializa a sessão vazia
    return {"sessionId": session_id}

aqui passo a mensagem assim que inicia a conversa

sendMessage(): void {
    const trimmedMessage = this.userMessage.trim();

    if (!trimmedMessage) {
      this.showNotification('warn', 'Atenção', 'Digite uma mensagem antes de enviar.');
      return;
    }

    // Adiciona a mensagem do usuário ao histórico
    this.messages.push({ role: 'user', content: trimmedMessage });

    // Limpa o campo de input e redefine a altura do textarea
    this.userMessage = '';
    this.resetTextAreaHeight();

    this.loading = true;
    this.showNotification('info', 'Enviando', 'Sua mensagem está sendo processada.');

    // Envia a mensagem ao backend
    this.servicoLLM.sendMessage(this.sessionId, trimmedMessage).subscribe({
      next: (response) => {
        // Adiciona a resposta do assistente ao histórico
        this.messages.push({ role: 'assistant', content: response.answer });
        this.loading = false;
        this.showNotification('success', 'Sucesso', 'Mensagem enviada com sucesso.');
        this.scrollToBottom();

        // Salvar mensagens no backend sem bloquear a interface
        const payloadUsuario = {
          numero_trabalho: this.nrTrabalho,
          matricula: this.usuario?.chaveFuncionario,
          sessao: this.sessionId,
          remetente: 'usuario',
          conteudo: trimmedMessage
        };
        this.servicoLLM.salvarMensagem(payloadUsuario).subscribe({
          next: (res) => {console.log('Mensagem do usuário salva:', res)
          const payloadAssistente = {
            numero_trabalho: this.nrTrabalho,
            matricula: this.usuario?.chaveFuncionario,
            sessao: this.sessionId,
            remetente: 'assistente',
            conteudo: response.answer
          };
          this.servicoLLM.salvarMensagem(payloadAssistente).subscribe({
            next: (res) => {console.log('Resposta do assistente salva:', res)
            this.alerta_uso_ia = true;
          },
            error: (err) => console.error('Erro ao salvar resposta do assistente:', err)
          });
          },
          error: (err) => console.error('Erro ao salvar mensagem do usuário:', err)
        });        
      },
      error: (err) => {
        console.error('Erro ao processar mensagem:', err);
        this.loading = false;
        this.showNotification('error', 'Erro', 'Erro ao processar sua mensagem. Tente novamente mais tarde.');
        this.messages.push({
          role: 'assistant',
          content: 'Erro ao processar sua mensagem. Por favor, tente novamente mais tarde.'
        });
        this.scrollToBottom();
      },
    });
  }

segue o backend que recebe o chat

class ChatRequest(BaseModel):
    sessionId: str
    userMessage: str
    roleUser: str = None  # Adicionado para passar o contexto inicial opcional
    roleAssistant: str = None  # Adicionado para passar o contexto inicial opcional

@router.post("/apiptai/chat")
def chat_endpoint(req: ChatRequest):
    """
    Endpoint para receber a mensagem do usuário e devolver a resposta da IA.
    """
    session_id = req.sessionId
    user_message = req.userMessage.strip()  # Remove espaços em branco
    role_user = req.roleUser
    role_assistant = req.roleAssistant

    # Verificar se os campos obrigatórios estão presentes
    if not session_id:
        return {"error": "Session ID is required"}
    if user_message == "" and (not role_user or not role_assistant):
        return {"error": "User message or initial context (roleUser and roleAssistant) is required"}

    # Inicializa a sessão se não existir
    if session_id not in sessions:
        sessions[session_id] = []
        print("Sessão inicializada")

    # Adiciona o contexto inicial à sessão, se fornecido
    if role_user and role_assistant and len(sessions[session_id]) == 0:
        print("Adicionando contexto inicial à sessão")
        sessions[session_id].append({"role": "assistant", "content": role_assistant})
        sessions[session_id].append({"role": "user", "content": role_user})

    # Adiciona a mensagem do usuário ao histórico, se for válida
    if user_message:
        sessions[session_id].append({"role": "user", "content": user_message})

    # Valida o histórico da sessão antes de enviar
    if len(sessions[session_id]) < 1:
        return {"error": "Session history is empty or invalid"}

    # Concatena o histórico da sessão para enviar ao modelo LLM
    prompt = "\n".join([f"{msg['role']}: {msg['content']}" for msg in sessions[session_id]])

    
    # Faz a chamada para o modelo usando a API LLM da empresa
    try:
        answer_text = assistentLLM(prompt, servico="http://acs-assist-sem-rag-mef.nia.hm.bb.com.br/acs/llms/agent")
    except requests.exceptions.HTTPError as http_err:
        # Tratar erro HTTP (como 500)
        print(f"Erro HTTP na chamada ao serviço LLM: {http_err}")
        return {"error": "Erro interno no servidor. Por favor, tente novamente mais tarde."}
    except Exception as e:
        # Tratar outros erros
        print(f"Erro ao processar resposta da LLM: {e}")
        return {"error": "Erro ao acessar o serviço de IA. Por favor, tente novamente mais tarde."}

    # Armazena a resposta do assistente no histórico
    sessions[session_id].append({"role": "assistant", "content": answer_text})

    # Retorna a resposta em JSON
    #time.sleep(60)
    return {"answer": answer_text}


como faço a documentação para quem quiser usar a api, no meu caso o front foi feito em angular e o backend em fastapi
a área quer usar essa api para uma aplicação deles que o front é em vue e o backend em java, não quero que vc entre em questoes tecnicas de desenvolvimento, apenas 
documentação de uso de api, ago do tipo, 

Chamada para criar api, chamada para obter os dados do trabalhos e o destaque gerado e a area de chat





