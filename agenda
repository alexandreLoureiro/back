
def extrair_rel_kpmg_pdf(pdf_bytes: bytes) -> str:
    pdf_stream = io.BytesIO(pdf_bytes)
    reader = PdfReader(pdf_stream)
    texto = ""
    for page in reader.pages:
        # Use page.extract_text(), que pode retornar None se não conseguir extrair
        page_text = page.extract_text()
        if page_text:
            texto += page_text + "\n"
    return texto.strip()

def remove_problematic_characters_from_string(text):
    problematic_characters = set()
    def remove_and_collect(x):
        if isinstance(x, str):
            encoded = x.encode('latin-1', 'ignore')
            decoded = encoded.decode('latin-1')
            for original_char, encoded_char in zip(x, decoded):
                if original_char != encoded_char:
                    problematic_characters.add(original_char)
            return decoded
        return x
    
    cleaned_text = remove_and_collect(text)
    return cleaned_text, problematic_characters

def remove_problematic_characters_from_dataframe(df):
    problematic_characters = set()
    def remove_and_collect(x):
        if isinstance(x, str):
            encoded = x.encode('latin-1', 'ignore')
            decoded = encoded.decode('latin-1')
            for original_char, encoded_char in zip(x, decoded):
                if original_char != encoded_char:
                    problematic_characters.add(original_char)
            return decoded
        return x
    
    df_cleaned = df.applymap(remove_and_collect)
    return df_cleaned, problematic_characters

def remove_accents(input_str: str) -> str:
    nfkd_form = unicodedata.normalize('NFD', input_str)
    return ''.join([c for c in nfkd_form if not unicodedata.combining(c)])

def extract_name(text: str) -> str:
    """
    Extrai a parte do nome até o primeiro caractere separador.
    São considerados: hífen (-), en dash (–), em dash (—) e o caractere \u0096.
    Em seguida, remove acentos, faz trim e converte para uppercase.
    """
    parts = re.split(r"[-–—\u0096]", text)
    print('parts ', parts)
    return remove_accents(parts[0].strip().upper())

@router.post("/apiptai/upload-rcm-excel-multiplos")
async def upload_rcm_excel_multiplos(request: Request):
    form = await request.form()

    # Define a variável para coletar caracteres problemáticos
    problematic_characters_df = set()

    # Pega o Excel
    file_excel: UploadFile = form.get("file_excel")
    if not file_excel:
        raise HTTPException(status_code=400, detail="Arquivo Excel (file_excel) é obrigatório.")
    
    file_extension = file_excel.filename.lower().split('.')[-1]
    if file_extension not in ["xlsx", "xls", "csv"]:
        raise HTTPException(status_code=400, detail="O arquivo Excel deve ser .xlsx, .xls ou .csv")
    
    excel_bytes = await file_excel.read()
    try:
        if file_extension == "csv":
            # Ajuste a codificação e delimitador conforme seu arquivo CSV
            df = pd.read_csv(io.BytesIO(excel_bytes), encoding='ISO-8859-1', sep=';', on_bad_lines='skip')
        else:
            df = pd.read_excel(io.BytesIO(excel_bytes))
        # Normaliza as colunas: remove espaços e converte para maiúsculas
        df.columns = df.columns.str.strip().str.upper()
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Erro ao ler Excel: {str(e)}")

    # Valida colunas obrigatórias
    colunas_obrigatorias = [
        "RELATORIO", "DATA_EMISSAO", "CONSTATACAO", "EVIDENCIAS", "RECOMENDACAO",
        "INSTITUICAO_RESPONSAVEL", "PREFIXO_RESPONSAVEL", "INSTITUICAO_ASSUNTO_ELBB",
        "PREVISAO_IMPLEMENTACAO", "MATRICULA_DO_GESTOR_RESPONSAVEL"
    ]
    for col in colunas_obrigatorias:
        if col not in df.columns:
            raise HTTPException(status_code=400, detail=f"Coluna '{col}' não encontrada no Excel.")

    # Processa PDFs
    pdf_keys = [key for key in form.keys() if key.startswith("file_pdf_")]
    if len(pdf_keys) == 0:
        raise HTTPException(status_code=400, detail="Nenhum PDF enviado (file_pdf_0, file_pdf_1, ...).")

    pdf_dict: Dict[str, bytes] = {}
    for key in pdf_keys:
        pdf_upload: UploadFile = form[key]
        if not pdf_upload.filename.lower().endswith(".pdf"):
            raise HTTPException(status_code=400, detail=f"O arquivo {pdf_upload.filename} não é PDF.")
        pdf_name_no_ext = extract_name(pdf_upload.filename.replace(".pdf", ""))
        pdf_content = await pdf_upload.read()
        pdf_dict[pdf_name_no_ext] = pdf_content

    # Converte o DataFrame para registros (dicionários) e filtra linhas sem RELATORIO
    df_records = df.to_dict("records")
    grouped: Dict[tuple, List[Dict]] = {}
    for row in df_records:
        # Pula a linha se RELATORIO for NaN ou vazio
        relatorio_raw = row.get("RELATORIO")
        if pd.isna(relatorio_raw) or str(relatorio_raw).strip() == "":
            continue

        data_emissao = str(row["DATA_EMISSAO"]).strip().upper()
        relatorio_val = extract_name(str(relatorio_raw))
        key = (data_emissao, relatorio_val)
        if key not in grouped:
            grouped[key] = []
        grouped[key].append(row)

    ids_inseridos_total = []
    for (data_emissao_val, relatorio_val), rows in grouped.items():
        # Apaga registros existentes com a mesma data_emissao e relatorio
        delete_query = "DELETE FROM rcm.rcm_kpmg_relatorios WHERE data_emissao = $1 AND relatorio = $2"
        await execute_query(delete_query, data_emissao_val, relatorio_val)

        # Insere cada linha para essa combinação
        for row in rows:
            constatacoes = str(row["CONSTATACAO"]).strip().upper()
            evidencias = str(row["EVIDENCIAS"]).strip().upper()
            recomendacao = str(row["RECOMENDACAO"]).strip().upper()
            instituicao_responsavel = str(row["INSTITUICAO_RESPONSAVEL"]).strip().upper()
            prefixo_responsavel = str(row["PREFIXO_RESPONSAVEL"]).strip().upper()
            instituicao_assunto_elbb = str(row["INSTITUICAO_ASSUNTO_ELBB"]).strip().upper()
            previsao_implementacao = str(row["PREVISAO_IMPLEMENTACAO"]).strip().upper()
            matricula_do_gestor_responsavel = str(row["MATRICULA_DO_GESTOR_RESPONSAVEL"]).strip().upper()

            pdf_bytes = pdf_dict.get(relatorio_val)
            if not pdf_bytes:
                raise HTTPException(
                    status_code=400,
                    detail=f"Falta PDF '{relatorio_val}.pdf' para o relatório '{relatorio_val}'."
                )

            # Extrai o texto do PDF usando a função extrair_rel_kpmg_pdf
            rel_text = extrair_rel_kpmg_pdf(pdf_bytes)
            
            # Remover caracteres problemáticos do texto extraído do PDF
            rel_text, problematic_characters_pdf = remove_problematic_characters_from_string(rel_text)
            problematic_characters_df.update(problematic_characters_pdf)

            novo_id = await inserir_linha_rcm(
                relatorio=relatorio_val,
                data_emissao=data_emissao_val,
                constatacoes=constatacoes,
                evidencias=evidencias,
                recomendacao=recomendacao,
                instituicao_responsavel=instituicao_responsavel,
                prefixo_responsavel=prefixo_responsavel,
                instituicao_assunto_elbb=instituicao_assunto_elbb,
                previsao_implementacao=previsao_implementacao,
                matricula_do_gestor_responsavel=matricula_do_gestor_responsavel,
                pdf_blob=pdf_bytes,
                relatorio_text_extract=rel_text  # type: ignore
            )
            if novo_id:
                ids_inseridos_total.append(novo_id)

    return {
        "status": "ok",
        "mensagem": "Upload múltiplo concluído com sobrescrita por data_emissao e relatorio.",
        "datas_processadas": list(grouped.keys()),
        "ids_inseridos": ids_inseridos_total
    }

nessa parte 

def extract_name(text: str) -> str:
    """
    Extrai a parte do nome até o primeiro caractere separador.
    São considerados: hífen (-), en dash (–), em dash (—) e o caractere \u0096.
    Em seguida, remove acentos, faz trim e converte para uppercase.
    """
    parts = re.split(r"[-–—\u0096]", text)
    print('parts ', parts)
    return remove_accents(parts[0].strip().upper())

esta imprimindo isso parts  ['CCI BB Consórcios ', ' 30.06.2024 ', ' Relatório sobre sistema controle interno BACEN ', ' Res. 4.910 e BCB 260']
parts  ['CCI BB Leasing ', ' 30.06.2024 ', ' BCB 130 062024']
parts  ['CCI BB ', ' 30/06/2024']
parts  ['CCI BB ', ' 30/06/2024']
parts  ['CCI BB ', ' 30/06/2024']
parts  ['CCI BB BI ', ' 30/06/2024']
parts  ['CCI BB BI ', ' 30/06/2024']
parts  ['CCI BB Consórcios ', ' 30/06/2024']
parts  ['CCI BB Consórcios ', ' 30/06/2024'], o que eu preciso é parte da data, nesse exemplo ' 30/06/2024', tenho que salvar como periodo de apuracao
entao, aqui é o retorno 
pdf_name_no_ext = extract_name(pdf_upload.filename.replace(".pdf", ""))
alem do nome quero a data, e essa que preciso, ai nao precisa mais do mes e ano

ai passa p ca também


async def inserir_linha_rcm(
    relatorio: str,
    data_emissao: str,
    constatacoes: str,
    evidencias: str,
    recomendacao: str,
    instituicao_responsavel: str,
    prefixo_responsavel: str,
    instituicao_assunto_elbb: str,
    previsao_implementacao: str,
    matricula_do_gestor_responsavel: str,
    pdf_blob: bytes,
    relatorio_text_extract: str
):
    """
    Insere uma linha na tabela rcm.rcm_kpmg_relatorios com todas as colunas, inclusive o texto extraído do PDF.
    """
    query = """
    INSERT INTO rcm.rcm_kpmg_relatorios (
      relatorio,
      data_emissao,
      constatacoes,
      evidencias,
      recomendacao,
      instituicao_responsavel,
      prefixo_responsavel,
      instituicao_assunto_elbb,
      previsao_implementacao,
      matricula_do_gestor_responsavel,
      pdf_file,
      relatorio_text_extract
    ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
    RETURNING id;
    """
    result = await execute_query(
        query,
        relatorio,
        data_emissao,
        constatacoes,
        evidencias,
        recomendacao,
        instituicao_responsavel,
        prefixo_responsavel,
        instituicao_assunto_elbb,
        previsao_implementacao,
        matricula_do_gestor_responsavel,
        pdf_blob,
        relatorio_text_extract,
        return_one=True
    )
    if result:
        return result.get("id")
    return None


