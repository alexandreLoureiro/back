from fastapi import APIRouter, File, UploadFile, Request, HTTPException, Form
from fastapi.responses import RedirectResponse, StreamingResponse, FileResponse, Response, JSONResponse

from fastapi.responses import HTMLResponse
from infra.sqlalchemy.queries_rcm.queries_rcm import tcu_upate_insert
import requests
import json
import shutil
from os import getcwd
import pandas as pd
import asyncio
import uuid 
from io import BytesIO
import io
#import fitz  # PyMuPDF
import PyPDF2
import re
import os
from datetime import datetime
from hashlib import sha256
from docx import Document
from docx.shared import RGBColor, Pt
import subprocess

from infra.sqlalchemy.config.constants_sso import ConstantsSSO
from infra.sqlalchemy.dao.dao import busca_matriz_risco_mapN1, busca_matriz_risco_mapN2
from infra.sqlalchemy.dao.queries_geral import inserir_relatorio_rcm, inserir_linha_rcm
from infra.sqlalchemy.config.conexoes import *
from infra.sqlalchemy.config.database_pool import pool, execute_query


import openpyxl 
import matplotlib.pyplot as plt 
from io import BytesIO

from openpyxl import Workbook 
# from openpyxl import Worksheet  
from PIL import Image 
from openpyxl.drawing.image import Image as ExcelImage

import imgkit 
import tempfile 

#import cv2
from matplotlib import pyplot as plt

DIR_FINAL = '/code/app/deoc/rcm_ae'
FILE_ACESSO = 'acesso.txt'

router = APIRouter()

def auth_func(goto_url, request):    
    constants_sso = ConstantsSSO(goto_url)
    token = constants_sso.get_token(request)
        
    if isinstance(token, RedirectResponse):
        print('nao está logado!')
        url = f"https://login.intranet.bb.com.br/distAuth/UI/Login?goto=https://mefis.bb.com.br/anaylitcs{goto_url}"
        return url
    
    elif isinstance(token, dict):
        return token

@router.delete("/apiptai/deletar_rcm_relatorio/{relatorio_id}")
async def deletar_rcm_relatorio(relatorio_id: int):
    """
    Deleta um relatório da tabela rcm.rcm_kpmg_relatorios pelo ID.
    Retorna o ID do relatório deletado ou erro 404 se não encontrado.
    """
    delete_query = "DELETE FROM rcm.rcm_kpmg_relatorios WHERE id = $1 RETURNING id;"
    result = await execute_query(delete_query, relatorio_id, return_one=True)
    if result and result.get("id"):
        return {"status": "ok", "id_deletado": result.get("id")}
    else:
        raise HTTPException(status_code=404, detail="Relatório não encontrado")

@router.post("/apiptai/rcmkpmg")
async def salvar_relatorio_rcm(
    nome: str = Form(...),
    data: str = Form(...),
    constatacoes: str = Form(...),
    recomendacoes: str = Form(...),
    file: UploadFile = File(...)
):
    # Lê o conteúdo binário do PDF
    pdf_bytes = await file.read()

    # Chama a função para inserir no PostgreSQL
    try:
        novo_id = await inserir_relatorio_rcm(nome, data, constatacoes, recomendacoes, pdf_bytes)
        return {
            "status": "ok",
            "id_inserido": novo_id,
            "mensagem": "Relatório RCM salvo com sucesso no banco."
        }
    except Exception as e:
        return {
            "status": "erro",
            "detalhe": str(e)
        }
        
@router.get("/apiptai/listar_rcm_relatorios")
async def listar_rcm_relatorios():
    query = """
    SELECT
      id,
      relatorio,               -- em vez de "nome"
      data_emissao,
      constatacoes,
      recomendacao AS recomendacoes  -- se quiser renomear no SELECT
    FROM rcm.rcm_kpmg_relatorios
    ORDER BY id ASC;
    """
    registros = await execute_query(query)
    return registros

@router.get("/apiptai/rcmkpmg/{relatorio_id}")
async def get_relatorio_rcm(relatorio_id: int):
    query = """
    SELECT pdf_file, relatorio, data_emissao, constatacoes, recomendacao
    FROM rcm.rcm_kpmg_relatorios
    WHERE id = $1;
    """
    resultado = await execute_query(query, relatorio_id, return_one=True)
    if not resultado:
        return {"erro": "Relatório não encontrado"}
    
    pdf_bytes = resultado['pdf_file']  # isto deve ser um campo BYTEA (bytes)

    # Abordagem 1: Retornar de uma vez só usando Response
    return Response(content=pdf_bytes, media_type="application/pdf")

    # Abordagem 2: Usar StreamingResponse
    # return StreamingResponse(
    #     io.BytesIO(pdf_bytes),
    #     media_type="application/pdf"
    # )
    
import io
from PyPDF2 import PdfReader

@router.get("/apiptai/rcmkpmg/{relatorio_id}")
async def get_relatorio_rcm(relatorio_id: int):
    query = """
    SELECT pdf_file, relatorio, data_emissao, constatacoes, recomendacao
    FROM rcm.rcm_relatorios
    WHERE id = $1;
    """
    resultado = await execute_query(query, relatorio_id, return_one=True)
    if not resultado:
        return {"erro": "Relatório não encontrado"}
    
    pdf_bytes = resultado['pdf_file']  # isto deve ser um campo BYTEA (bytes)

    # Abordagem 1: Retornar de uma vez só usando Response
    return Response(content=pdf_bytes, media_type="application/pdf")

    # Abordagem 2: Usar StreamingResponse
    # return StreamingResponse(
    #     io.BytesIO(pdf_bytes),
    #     media_type="application/pdf"
    # )

def extrair_rel_kpmg_pdf(pdf_bytes: bytes) -> str:
    pdf_stream = io.BytesIO(pdf_bytes)
    reader = PdfReader(pdf_stream)
    texto = ""
    for page in reader.pages:
        # Use page.extract_text(), que pode retornar None se não conseguir extrair
        page_text = page.extract_text()
        if page_text:
            texto += page_text + "\n"
    return texto.strip()

def remove_problematic_characters_from_string(text):
    problematic_characters = set()
    def remove_and_collect(x):
        if isinstance(x, str):
            encoded = x.encode('latin-1', 'ignore')
            decoded = encoded.decode('latin-1')
            for original_char, encoded_char in zip(x, decoded):
                if original_char != encoded_char:
                    problematic_characters.add(original_char)
            return decoded
        return x
    
    cleaned_text = remove_and_collect(text)
    return cleaned_text, problematic_characters

def remove_problematic_characters_from_dataframe(df):
    problematic_characters = set()
    def remove_and_collect(x):
        if isinstance(x, str):
            encoded = x.encode('latin-1', 'ignore')
            decoded = encoded.decode('latin-1')
            for original_char, encoded_char in zip(x, decoded):
                if original_char != encoded_char:
                    problematic_characters.add(original_char)
            return decoded
        return x
    
    df_cleaned = df.applymap(remove_and_collect)
    return df_cleaned, problematic_characters
    

@router.post("/apiptai/upload-rcm-excel-multiplos")
async def upload_rcm_excel_multiplos(request: Request):
    form = await request.form()

    # Pega o Excel
    file_excel: UploadFile = form.get("file_excel")
    if not file_excel:
        raise HTTPException(status_code=400, detail="Arquivo Excel (file_excel) é obrigatório.")
    if not (file_excel.filename.lower().endswith(".xlsx") or file_excel.filename.lower().endswith(".xls")):
        raise HTTPException(status_code=400, detail="O arquivo Excel deve ser .xlsx ou .xls")

    excel_bytes = await file_excel.read()
    try:
        df = pd.read_excel(BytesIO(excel_bytes))
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Erro ao ler Excel: {str(e)}")

    # Remover caracteres problemáticos do DataFrame e coletá-los
    df, problematic_characters_df = remove_problematic_characters_from_dataframe(df)
    #print(f"Eliminated problematic characters from DataFrame: {problematic_characters_df}")

    # Valida colunas obrigatórias
    colunas_obrigatorias = [
        "RELATORIO", "DATA_EMISSAO", "CONSTATACAO", "EVIDENCIAS", "RECOMENDACAO",
        "INSTITUICAO_RESPONSAVEL", "PREFIXO_RESPONSAVEL", "INSTITUICAO_ASSUNTO_ELBB",
        "PREVISAO_IMPLEMENTACAO", "MATRICULA_DO_GESTOR_RESPONSAVEL"
    ]
    for col in colunas_obrigatorias:
        if col not in df.columns:
            raise HTTPException(status_code=400, detail=f"Coluna '{col}' não encontrada no Excel.")

    # PDFs
    pdf_keys = [key for key in form.keys() if key.startswith("file_pdf_")]
    if len(pdf_keys) == 0:
        raise HTTPException(status_code=400, detail="Nenhum PDF enviado (file_pdf_0, file_pdf_1, ...).")

    pdf_dict: Dict[str, bytes] = {}
    for key in pdf_keys:
        pdf_upload: UploadFile = form[key]
        if not pdf_upload.filename.lower().endswith(".pdf"):
            raise HTTPException(status_code=400, detail=f"O arquivo {pdf_upload.filename} não é PDF.")
        pdf_name_no_ext = pdf_upload.filename.replace(".pdf", "").strip()
        pdf_content = await pdf_upload.read()
        pdf_dict[pdf_name_no_ext] = pdf_content

    # Agrupa o DataFrame pela coluna DATA_EMISSAO
    df_records = df.to_dict("records")
    grouped: Dict[str, List[Dict]] = {}
    for row in df_records:
        data_emissao = str(row["DATA_EMISSAO"]).strip()
        if data_emissao not in grouped:
            grouped[data_emissao] = []
        grouped[data_emissao].append(row)

    ids_inseridos_total = []
    for data_emissao_val, rows in grouped.items():
        # Apaga registros com a mesma data_emissao
        delete_query = "DELETE FROM rcm.rcm_kpmg_relatorios WHERE data_emissao = $1"
        await execute_query(delete_query, data_emissao_val)

        # Insere cada linha para essa data_emissao
        for row in rows:
            print('row', row)
            relatorio_val = str(row["RELATORIO"]).strip()
            constatacoes = str(row["CONSTATACAO"]).strip()
            evidencias = str(row["EVIDENCIAS"]).strip()
            recomendacao = str(row["RECOMENDACAO"]).strip()
            instituicao_responsavel = str(row["INSTITUICAO_RESPONSAVEL"]).strip()
            prefixo_responsavel = str(row["PREFIXO_RESPONSAVEL"]).strip()
            instituicao_assunto_elbb = str(row["INSTITUICAO_ASSUNTO_ELBB"]).strip()
            previsao_implementacao = str(row["PREVISAO_IMPLEMENTACAO"]).strip()
            matricula_do_gestor_responsavel = str(row["MATRICULA_DO_GESTOR_RESPONSAVEL"]).strip()

            pdf_bytes = pdf_dict.get(relatorio_val)
            if not pdf_bytes:
                raise HTTPException(
                    status_code=400,
                    detail=f"Falta PDF '{relatorio_val}.pdf' para o relatório '{relatorio_val}'."
                )

            # Extrai o texto do PDF usando a função extrair_rcm_kpmg
            rel_text = extrair_rel_kpmg_pdf(pdf_bytes)
            
            # Remover caracteres problemáticos do texto extraído do PDF
            rel_text, problematic_characters_pdf = remove_problematic_characters_from_string(rel_text)
            problematic_characters_df.update(problematic_characters_pdf)
            #print(f"Eliminated problematic characters from PDF: {problematic_characters_pdf}")

            novo_id = await inserir_linha_rcm(
                relatorio=relatorio_val,
                data_emissao=data_emissao_val,
                constatacoes=constatacoes,
                evidencias=evidencias,
                recomendacao=recomendacao,
                instituicao_responsavel=instituicao_responsavel,
                prefixo_responsavel=prefixo_responsavel,
                instituicao_assunto_elbb=instituicao_assunto_elbb,
                previsao_implementacao=previsao_implementacao,
                matricula_do_gestor_responsavel=matricula_do_gestor_responsavel,
                pdf_blob=pdf_bytes,
                relatorio_text_extract=rel_text # type: ignore
            )
            if novo_id:
                ids_inseridos_total.append(novo_id)

    return {
        "status": "ok",
        "mensagem": "Upload múltiplo concluído com sobrescrita por data_emissao.",
        "datas_processadas": list(grouped.keys()),
        "ids_inseridos": ids_inseridos_total
    }


@router.post("/apiptai/upload-rcm-excel-pdf")
async def upload_rcm_excel_pdf(
    file_pdf: UploadFile = File(...),
    file_excel: UploadFile = File(...),
):
    # 1) Validar extensão do PDF
    if not file_pdf.filename.lower().endswith(".pdf"):
        raise HTTPException(status_code=400, detail="O arquivo PDF não possui extensão .pdf")

    # 2) Ler o arquivo Excel em memória
    if not (file_excel.filename.lower().endswith(".xlsx") or file_excel.filename.lower().endswith(".xls")):
        raise HTTPException(status_code=400, detail="O arquivo de Excel deve ser .xlsx ou .xls")

    # Lê o Excel para dataframe
    contents_excel = await file_excel.read()
    df = pd.read_excel(contents_excel)

    # 3) Validar colunas obrigatórias (exemplo)
    colunas_obrigatorias = [
        "RELATORIO", "DATA_EMISSAO", "CONSTATACAO", "EVIDENCIAS", "RECOMENDACAO",
        "INSTITUICAO_RESPONSAVEL", "PREFIXO_RESPONSAVEL", "INSTITUICAO_ASSUNTO_ELBB",
        "PREVISAO_IMPLEMENTACAO", "MATRICULA_DO_GESTOR_RESPONSAVEL"
    ]
    for col in colunas_obrigatorias:
        if col not in df.columns:
            raise HTTPException(status_code=400, detail=f"Coluna obrigatória '{col}' não encontrada no Excel.")

    # 4) Verificar os valores da coluna RELATORIO
    valores_relatorio = df["RELATORIO"].unique()  # array de valores únicos
    if len(valores_relatorio) == 0:
        raise HTTPException(status_code=400, detail="A planilha não possui valores na coluna RELATORIO.")

    # Regra de ter APENAS UM valor de RELATORIO distinto
    if len(valores_relatorio) > 1:
        # Dependendo da sua regra, pode permitir ou rejeitar
        raise HTTPException(
            status_code=400,
            detail=f"Existem {len(valores_relatorio)} valores de RELATORIO distintos. Envie planilhas separadas."
        )

    # 5) Comparar com o nome do PDF (sem extensão)
    relatorio_excel = valores_relatorio[0]  # ex.: "CCI BB – 30/06/2024"
    pdf_name_no_ext = file_pdf.filename.replace(".pdf", "")  # ex.: "CCI BB – 30/06/2024"

    if relatorio_excel.strip() != pdf_name_no_ext.strip():
        raise HTTPException(
            status_code=400,
            detail=(
                f"O valor de RELATORIO ('{relatorio_excel}') não coincide com o nome do PDF ('{pdf_name_no_ext}')."
            )
        )

    # 6) Se chegou até aqui, está tudo validado. Podemos salvar ambos os arquivos, se quiser.
    # Por exemplo, salvando em /code/app/uploads:
    upload_dir = "/code/app/uploads"
    if not os.path.exists(upload_dir):
        os.makedirs(upload_dir)

    # Salvar PDF
    pdf_path = os.path.join(upload_dir, file_pdf.filename)
    with open(pdf_path, "wb") as f:
        contents_pdf = await file_pdf.read()
        f.write(contents_pdf)

    # Salvar Excel
    excel_path = os.path.join(upload_dir, file_excel.filename)
    with open(excel_path, "wb") as f:
        f.write(contents_excel)

    # 7) Você pode processar as linhas do df e salvar no banco
    #    ou devolver um "preview" do que foi importado, etc.

    return {
        "status": "ok",
        "mensagem": "Upload realizado com sucesso!",
        "relatorio": relatorio_excel,
        "nome_pdf": pdf_name_no_ext,
        "total_linhas_excel": len(df)
    }

    
@router.get("/apiptai/rcmkpmg/{relatorio_id}")
async def get_relatorio_rcm(relatorio_id: int):
    query = """
    SELECT pdf_file, nome, data, constatacoes, recomendacoes
    FROM rcm.rcm_kpmg_relatorios
    WHERE id = $1;
    """
    resultado = await execute_query(query, relatorio_id, return_one=True)
    if not resultado:
        return {"erro": "Relatório não encontrado"}
    
    pdf_bytes = resultado['pdf_file']  # isto deve ser um campo BYTEA (bytes)

    # Abordagem 1: Retornar de uma vez só usando Response
    return Response(content=pdf_bytes, media_type="application/pdf")

    # Abordagem 2: Usar StreamingResponse
    # return StreamingResponse(
    #     io.BytesIO(pdf_bytes),
    #     media_type="application/pdf"
    # )

@router.post("/files/")
async def create_file(file: bytes = File(...)):
    return {"file_size": len(file)}


@router.post("/uploadfile/")
async def create_upload_file(file: UploadFile = File(...)):
    return {"filename": file.filename}


@router.post("/uploadfile2/")
async def image(image: UploadFile = File(...)):
    with open("/code/app/" + image.filename, "wb") as buffer:
        shutil.copyfileobj(image.file, buffer)
    return {"filename": image.filename}


@router.post("/uploadfile3/")
async def uploadfile3(uploaded_file: UploadFile = File(...)):
    file_location = f"/code/app/{uploaded_file.filename}"
    with open(file_location, "wb+") as file_object:
        file_object.write(uploaded_file.file.read())
    return {"info": f"file '{uploaded_file.filename}' saved at '{file_location}'"}


@router.post("/apiptai/uploadarquivo/")
async def uploadfile3(nome: str, file: UploadFile = File(...)):
    upload_dir = "/code/app/"
    
    # Verifique se o nome do arquivo é válido
    if not nome:
        return {"error": "Nome de arquivo inválido"}
    
    # Crie o caminho completo do arquivo usando o nome fornecido
    file_location = os.path.join(upload_dir, nome)
    
    # Salve o arquivo no caminho especificado
    with open(file_location, "wb+") as file_object:
        file_object.write(file.file.read())
    
    return {"info": f"Arquivo '{nome}' salvo em '{file_location}'"}

@router.get("/apiptai/getpdf/{token}")
async def get_pdf(token: str):
    try:
        # Converter o token em um timestamp Unix (em milissegundos)
        
        arquivo = token.split("-")
        
        token_parts = arquivo[1].split(":")
        
        expected_hash = sha256("mefis".encode()).hexdigest()
        
        if token_parts[1] == expected_hash:
            print(' achou')
        else:
            print('nao ')
                
        
        timestamp_ms = int(token_parts[0])
        
        # Converter o timestamp para segundos
        timestamp = timestamp_ms / 1000.0
        
        # Obter a data atual
        current_time = datetime.now()
        
        # Converter o timestamp em uma data
        token_time = datetime.fromtimestamp(timestamp)
        
        # Calcular a diferença de tempo em segundos
        time_difference = (current_time - token_time).total_seconds()
        
        print('timestamp ', timestamp)
        print('current_time ', current_time)
        print('token_time ', token_time)
        print('(current_time - token_time).total_seconds() ', (current_time - token_time).total_seconds())
        
        # Verificar se a diferença entre a data atual e a data do token é menor do que 60 segundos (1 minuto)
        if time_difference < 60:
            file_location = f"/code/app/{arquivo[0]}"
            return FileResponse(file_location, media_type="application/pdf")
        else:
            raise HTTPException(status_code=401, detail="Recurso expirado - acessar aplicaçao")
    except ValueError:
        raise HTTPException(status_code=400, detail="Token inválido")

def extrair_texto_pdf(caminho_pdf):
    texto_total = ""
    with open(caminho_pdf, 'rb') as file:
        leitor_pdf = PyPDF2.PdfReader(file)
        for num_pagina in range(len(leitor_pdf.pages)):
            pagina = leitor_pdf.pages[num_pagina]
            texto_pagina = pagina.extract_text()  # Note a mudança aqui também para extract_text()
            texto_total += texto_pagina + "\n"
    return texto_total


# Função para extrair informações específicas do texto do ofício
def extrair_informacoes_oficio(texto_oficio):
    informacoes = {}
    match_oficio = re.search(r"OFÍCIO (\d+/\d+-TCU/\w+)", texto_oficio)
    match_data = re.search(r"Brasília-DF, (\d{1,2}/\d{1,2}/\d{4}).", texto_oficio)
    match_processo = re.search(r"Processo TC (\d+\.\d+/\d{4}-\d)", texto_oficio)
    match_tipo_processo = re.search(r"Tipo do processo: ([\w\s]+)", texto_oficio)
    match_assunto = re.search(r"Assunto: ([\w\s,.]+)\n", texto_oficio)
    match_anexo = re.search(r"Anexo: ([\w\s,.]+)\n", texto_oficio)
    #match_texto_apos = texto_oficio.split("Senhora Presidente,")
    match_texto_apos = re.split('Senhor Presidente,|Senhora Presidente,', texto_oficio)
    padrao_acordao = padrao_acordao = re.compile(r'(ACÓRDÃO N.*?)(?=DESPACHO|TERMO DE CIÊNCIA DE COMUNICAÇÃO)', re.DOTALL)
    match_acordao = padrao_acordao.search(texto_oficio)    
    padrao_conclusao = re.compile(r'CONCLUSÃO.*?(?=(INFORMAÇÕES ADICIONAIS|PROPOSTA DE ENCAMINHAMENTO|$))', re.DOTALL)
    match_conclusao = padrao_conclusao.search(texto_oficio)    
    padrao_informacoes_adicionais = re.compile(r'INFORMAÇÕES ADICIONAIS.*?(?=(PROPOSTA DE ENCAMINHAMENTO|\(Assinado eletronicamente\)|$))', re.DOTALL)
    match_informacoes_adicionais = padrao_informacoes_adicionais.search(texto_oficio)
    padrao_proposta_encaminhamento = re.compile(r'PROPOSTA DE ENCAMINHAMENTO.*?(?=(\(Assinado eletronicamente\)|TERMO DE CIÊNCIA DE COMUNICAÇÃO|$))', re.DOTALL)
    match_proposta_encaminhamento = padrao_proposta_encaminhamento.search(texto_oficio)    
    padrao_despacho = re.compile(r'(DESPACHO.*?)(?=\(Assinado eletronicamente\)|TERMO DE CIÊNCIA DE COMUNICAÇÃO)', re.DOTALL)
    match_despacho = padrao_despacho.findall(texto_oficio)

    padrao_introducao = re.compile(r'INTRODUÇÃO.*?(?=(\n[A-ZÁÉÍÓÚÂÊÎÔÛÃÕÄËÏÖÜÇ\s]+\n|$))', re.DOTALL)
    match_introducao = padrao_introducao.search(texto_oficio)
    padrao_admissibilidade = re.compile(r'EXAME DE ADMISSIBILIDADE.*?(?=(\n[A-ZÁÉÍÓÚÂÊÎÔÛÃÕÄËÏÖÜÇ\s]+\n|$))', re.DOTALL)
    match_admissibilidade = padrao_admissibilidade.search(texto_oficio) 
    padrao_exame_tecnico = re.compile(r'EXAME TÉCNICO SUMÁRIO.*?(?=(\n[A-ZÁÉÍÓÚÂÊÎÔÛÃÕÄËÏÖÜÇ\s]+\n|$))', re.DOTALL)
    match_exame_tecnico = padrao_exame_tecnico.search(texto_oficio) 


    

 
    informacoes['informacoes_adicionais']  = ''
    informacoes['conclusao']  = ''
    informacoes['proposta_encerramento']  = ''
    informacoes['proposta_encaminhamento']  = ''
    informacoes['acordao']  = ''
    informacoes['despacho']  = ''
    informacoes['introducao']  = ''
    informacoes['admissibilidade']  = ''
    informacoes['exame_tecnico']  = ''
    informacoes['assunto']  = ''
    informacoes['solicitacao']  = ''
    
    
    if match_oficio:
        informacoes['oficio'] = match_oficio.group(1)
    if match_data:
        informacoes['data'] = match_data.group(1)
    if match_processo:
        informacoes['processo'] = match_processo.group(1)
    if match_tipo_processo:
        informacoes['tipo_processo'] = match_tipo_processo.group(1).strip()
    if match_assunto:
        informacoes['assunto'] = match_assunto.group(1).strip()
    if match_anexo:
        informacoes['anexo'] = match_anexo.group(1).strip()
    if len(match_texto_apos) > 1:
        informacoes['solicitacao'] = match_texto_apos[1].strip()
    if match_acordao:
        informacoes['acordao'] = match_acordao.group(1).rstrip()
    if match_despacho:
        informacoes['despacho'] = match_despacho[-1].rstrip()  # pega a última correspondência
    if match_conclusao:
        informacoes['conclusao']  = match_conclusao.group()
    if match_introducao:
        informacoes['introducao'] = match_introducao.group(0).rstrip()  # Use group(0) to get the entire matched string
    if match_proposta_encaminhamento:
        informacoes['proposta_encaminhamento']  = match_proposta_encaminhamento.group()
    
    if match_introducao:
        informacoes['introducao'] = match_introducao.group() 
    if match_admissibilidade:
        informacoes['admissibilidade'] = match_admissibilidade.group()
    if match_exame_tecnico:
        informacoes['exame_tecnico'] = match_exame_tecnico.group()

    return informacoes

@router.post("/apiptai/uploadplanejai/")
async def uploadplanejai(file: UploadFile = File(...)):
    # Nome do arquivo esperado
    nome_esperado = "temas_complexo.xlsx"
    
    # Lista de colunas obrigatórias
    colunas_obrigatorias = ['prefixo', 'relevancia', 'tema', 'foco', 'ecbb', 'participantes']  # Substitua pelos nomes reais
    
    if file.filename != nome_esperado:
        raise HTTPException(status_code=400, detail=f"Nome do arquivo não é o esperado. Esperado: {nome_esperado}")
    
    with open(f"{file.filename}", "wb") as buffer:
        buffer.write(await file.read())
    
    df = pd.read_excel(file.filename, engine='openpyxl')
    
    print(df.columns)

    if not all(col in df.columns for col in colunas_obrigatorias):
        raise HTTPException(status_code=400, detail=f"O arquivo deve conter as colunas obrigatórias: {colunas_obrigatorias}")
    
    df['id'] = range(1, len(df) + 1)

    # Variáveis de autenticação
    USR_PG_ROOT = 'usr_cainf'
    PWD_PG_ROOT = '96019821'

    # Chamar a função passando os parâmetros
    conn, engine = postgres(db="sala_agil", usr=USR_PG_ROOT, pw=PWD_PG_ROOT)
    
    df['processamento'] = datetime.now()
    df.dropna(subset=['prefixo'], inplace=True)
    df.to_sql('temas_complexo_2025', engine, schema='planejamento', if_exists='replace', index=False)
    
    return {"filename": file.filename, "status": "success"}

@router.post("/apiptai/uploadarquivo_tcu/")
async def uploadfile3(nome: str, file: UploadFile = File(...)):
    upload_dir = "/code/app/tcu"

    if not os.path.exists(upload_dir):
        os.makedirs(upload_dir)

    file_location = os.path.join(upload_dir, file.filename)

    with open(file_location, "wb+") as file_object:
        contents = await file.read()
        file_object.write(contents)

    texto_extraido = "Não é um arquivo PDF"
    informacoes_oficio = {}

    if file.filename.endswith('.pdf'):
        texto_extraido = extrair_texto_pdf(file_location)
        informacoes_oficio = extrair_informacoes_oficio(texto_extraido)
        informacoes_oficio['texto_oficio'] =texto_extraido
        informacoes_oficio['status_oficio'] = await tcu_upate_insert(informacoes_oficio)
    os.remove(file_location)

    return {
        "info": f"Arquivo '{nome}' salvo temporariamente em '{file_location}' para extração de texto.",
        "nome_arquivo": file.filename,
        "tipo_conteudo": file.content_type,
        "tamanho_arquivo": len(contents),
        "texto_extraido": texto_extraido,
        "informacoes_oficio": informacoes_oficio
    }

@router.post("/apiptai/uploadfile4/")
async def uploadfile4(image: UploadFile = File(...)):
    with open(getcwd() + "/app/" + image.filename, "wb") as buffer:
        content = await image.read()
        buffer.write(content)
        buffer.close()
        # shutil.copyfileobj(image.file, buffer)

    return {"filename": image.filename}


@router.post("/apiptai/excel2/", response_class=FileResponse)
async def excel2():
    return FileResponse(getcwd() + "/app/teste.xlsx", media_type="application/vnd.ms-excel")


@router.post("/apiptai/get_body/")
async def get_body(request: Request):
    nm_tabela = 'teste'

    df = pd.DataFrame(await request.json())
    df_1 = df.reset_index(drop=True)

    # create an output stream
    output = BytesIO()
    writer = pd.ExcelWriter(output, engine='xlsxwriter')

    # taken from the original question
    df_1.to_excel(writer, startrow=0, merge_cells=False, sheet_name=nm_tabela)
    workbook = writer.book
    worksheet = writer.sheets[nm_tabela]
    format = workbook.add_format()
    format.set_bg_color('#eeeeee')
    worksheet.set_column(0, 9, 28)

    # the writer has done its job
    writer.close()

    # go back to the beginning of the stream
    output.seek(0)

    return StreamingResponse(
        io.BytesIO(output.getvalue()),
        media_type='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
        headers={"Content-Disposition": f'attachment; filename="teste.xlsx"'}
    )




@router.get("/apiptai/amostra/")
async def download_file2(request: Request):
    
    goto_url= "https://mefis.bb.com.br/apiptai/amostra/"    
    constants_sso = ConstantsSSO(goto_url)
    token = constants_sso.get_token(request)
        
    if isinstance(token, RedirectResponse):
        url = f"https://login.intranet.bb.com.br/distAuth/UI/Login?goto={goto_url}"
        return RedirectResponse(url) 
        
    elif isinstance(token, dict):
        file_path = "/code/app/Gera_Amostra.sas"  # Especifique o caminho correto para o arquivo no seu servidor
        data_hora_atual = datetime.now().strftime("%d/%m/%y - %H:%M")
        
        # Gerar o cabeçalho personalizado
        header = "/**********************************************************************************************************************************\n"
        header += f"** Arquivo baixado por {token.get('chaveFuncionario')} - {token.get('displayname')} em {data_hora_atual} **\n"
        header += "*********************************************************************************************************************************/;\n"

        # Caminho para o arquivo "Gera_Amostra.sas"
        
        # Ler o conteúdo do arquivo
        with open(file_path, "r", encoding="latin-1") as arquivo:
            conteudo = arquivo.read()

        # Adicionar o cabeçalho personalizado ao início do conteúdo
        novo_conteudo = header + conteudo

        # Escrever o conteúdo modificado de volta ao arquivo
        temp_file_path = "/code/app/Gera_Amostra_temp.sas"
        with open(temp_file_path, "w", encoding="latin-1") as arquivo_temp:
            arquivo_temp.write(novo_conteudo)

        # Gere o nome do arquivo com base na versão, data e hora
        versao = "1.0"  # Substitua pela versão do arquivo
        #nome_arquivo = f"Gera_Amostra_{versao}_{data_hora_atual}.sas"
        nome_arquivo = f"Gera_Amostra.sas"
        
        headers = {
            "Content-Disposition": f"attachment; filename={nome_arquivo}",
            "Content-Type": "application/octet-stream"
        }
            
        return StreamingResponse(open(temp_file_path, "rb"), headers=headers)
    
    else:
        return 'Erro servidor Mefis'


def escrever_em_documento_word(nome_documento, texto):
    
    # Abra o documento existente ou crie um novo
    doc = Document(nome_documento)

    # Acesse o cabeçalho da primeira seção do documento
    header = doc.sections[0].header

    # Adicione o texto ao cabeçalho

    paragraph = header.paragraphs[0]
    paragraph.text = ""

    run = paragraph.add_run("")
    font = run.font
    font.color.rgb = RGBColor(255, 0, 0)
    font.size = Pt(14)
    
    run2 = paragraph.add_run(texto)
    font = run2.font
    font.color.rgb = RGBColor(226, 83, 3)
    
    # Salve as mudanças
    doc.save(nome_documento)

@router.get("/apiptai/download_mpp/")
async def download_mpp(request: Request):
    goto_url= "/apiptai/download_mpp/"
    token = auth_func(goto_url, request)

    if isinstance(token, dict):
        data_hora_atual = datetime.now().strftime("%d/%m/%y - %H:%M")        
        # Gerar o cabeçalho personalizado
        texto = "***** Consumo interno para validação da Mefis ;\n"
        texto += f"***** Arquivo baixado por {token.get('chaveFuncionario')} - {token.get('displayname')} em {data_hora_atual} *****\n"
        
        caminho_arquivo_original =  "/code/app/MetodologiaPriorizacaoProcessos.docx"
        caminho_arquivo_copiado =  "/code/app/MetodologiaPriorizacaoProcessos_edit.docx"

        # Copie o arquivo original para realizar as alterações
        shutil.copy(caminho_arquivo_original, caminho_arquivo_copiado)

        # Escreva no documento se ainda não foi escrito
        try:
            with open(caminho_arquivo_copiado, "rb"):
                pass
        except FileNotFoundError:
            escrever_em_documento_word(caminho_arquivo_copiado, texto)

        # Escreva o texto no documento copiado
        escrever_em_documento_word(caminho_arquivo_copiado, texto)

        # Retorna o arquivo alterado ao usuário
        return FileResponse(caminho_arquivo_copiado, filename="MetodologiaPriorizacaoProcessos_edit.docx")
    
    else:
        return RedirectResponse(token)
    

@router.get("/apiptai/download_tutorial_pln/")
async def download_tutorial_pln(request: Request):
    caminho_arquivo_original =  "/code/app/tutorial_pln_2024.pdf"
    
    return FileResponse(caminho_arquivo_original, filename="tutorial_pln_2024_v01.pdf")


@router.get("/apiptai/download_tutorial_pln2/")
async def download_tutorial_pln2(request: Request):
    goto_url= "/apiptai/download_tutorial_pln/"
    token = auth_func(goto_url, request)

    if isinstance(token, dict):
        data_hora_atual = datetime.now().strftime("%d/%m/%y - %H:%M")        
        # Gerar o cabeçalho personalizado
        texto = f"***** Arquivo baixado por {token.get('chaveFuncionario')} - {token.get('displayname')} em {data_hora_atual} *****\n"
        caminho_arquivo_original =  "/code/app/tutorial_pln_2024.pdf"
        caminho_arquivo_copiado =  "/code/app/tutorial_pln_2024_edit.pdf"

        # Copie o arquivo original para realizar as alterações
        shutil.copy(caminho_arquivo_original, caminho_arquivo_copiado)

        # Escreva no documento se ainda não foi escrito
        #try:
        #    with open(caminho_arquivo_copiado, "rb"):
        #        pass
        #except FileNotFoundError:
        #    escrever_em_documento_word(caminho_arquivo_copiado, texto)

        # Escreva o texto no documento copiado
        #escrever_em_documento_word(caminho_arquivo_copiado, texto)

        # Retorna o arquivo alterado ao usuário
        return FileResponse(caminho_arquivo_original, filename="tutorial_pln_2024_v01.pdf")
    
    else:
        return RedirectResponse(token)


@router.get("/apiptai/get_token")
async def get_token(request: Request):
    goto_url= "https://mefis.bb.com.br/apiptai/get_token"
    
    constants_sso = ConstantsSSO(goto_url)

    token = constants_sso.get_token(request)
    return token

@router.get("/apiptai/export_excel_as_png/") 
async def export_excel_as_png(): 
    # Criar um arquivo Excel com openpyxl 
    wb = openpyxl.Workbook() 
    ws = wb.active 
    ws['A1'] = 'Exemplo de Dados' 
    ws['A2'] = 'Dado 1' 
    ws['B2'] = 'Dado 2' # Plotar gráfico de barras usando matplotlib 
    
    #fig, ax = plt.subplots()
    #ax.bar(['Dado 1', 'Dado 2'], [10, 20])
    #ax.set_ylabel('Valores') 
    # Salvar a figura como PNG em memória 
    #png_bytes_io = BytesIO() 
    #plt.savefig(png_bytes_io, format='png') 
    #plt.close() 
    # Retornar a imagem PNG como resposta 
    #return StreamingResponse(iter([png_bytes_io.getvalue()]), media_type="image/png")

    for i in range(1, 10): 
        ws[f'A{i + 2}'] = f'Dado {i}' 
        ws[f'B{i + 2}'] = i * 2 

    # Salvar a planilha em um arquivo temporário 
    excel_file = tempfile.NamedTemporaryFile(suffix='.xlsx', delete=False) 
    wb.save(excel_file.name) 

    # Definir opções para capturar a imagem 

    options = { 
    'page-size': 'A4', 
    'no-images': '', 
    'disable-smart-width': '', 
    'disable-external-links': '' 
    } 
    # Capturar a planilha Excel como uma imagem PNG 
    image_file = tempfile.NamedTemporaryFile(suffix='.png', delete=False) 
    imgkit.from_file(excel_file.name, image_file.name, options=options) 
    # Retornar a imagem PNG como resposta 
    return FileResponse(image_file.name, media_type="image/png")
        
    

#@router.get("/apiptai/get_user_attributes/{token_id}")
#async def get_user_attributes(token_id: str):
#    goto_url= "https://mefis.bb.com.br/taxonomia"
#    return constants_sso.get_user_attributes(token_id)
    

#@router.get("/apiptai/get_login_url")
#async def get_login_url():
#    return constants_sso.get_login_url()




@router.get("/apiptai/uploadarquivo_tcu", response_class=HTMLResponse)
async def get_upload_form():
    return """
    <html>
    <head>
        <title>Upload de Arquivo</title>
    </head>
    <body>
        <h1>Upload de Arquivo</h1>
        <form action="/apiptai/uploadarquivo_tcu_server_side/" method="post" enctype="multipart/form-data">
            <label for="file">Selecione o arquivo:</label>
            <input type="file" id="file" name="file" accept=".pdf" required><br><br>
            <input type="submit" value="Enviar">
        </form>
    </body>
    </html>
    """

# Rota para processar o upload de arquivo
@router.post("/apiptai/uploadarquivo_tcu_server_side/")
async def upload_file2(file: UploadFile = File(...)):
    upload_dir = "/code/app/tmp"

    if not os.path.exists(upload_dir):
        os.makedirs(upload_dir)

    file_location = os.path.join(upload_dir, file.filename)

    with open(file_location, "wb+") as file_object:
        contents = await file.read()
        file_object.write(contents)

    texto_extraido = "Não é um arquivo PDF"
    informacoes_oficio = {}

    if file.filename.endswith('.pdf'):
        # Se necessário, adicione aqui o processamento do arquivo PDF
        pass

    return {
        "info": f"Arquivo '{file.filename}' salvo temporariamente em '{file_location}' para processamento.",
        "nome_arquivo": file.filename,
        "tipo_conteudo": file.content_type,
        "tamanho_arquivo": len(contents),
        "texto_extraido": texto_extraido,
        "informacoes_oficio": informacoes_oficio
    }


@router.post("/apiptai/uploadarquivo_tcu2/")
async def upload_file_chunk(file: UploadFile = File(...), chunk_number: int = Form(...), total_chunks: int = Form(...)):
    upload_dir = "/code/app/tmp"
    if not os.path.exists(upload_dir):
        os.makedirs(upload_dir)

    # Gerar um nome de arquivo único usando uuid
    file_name = str(uuid.uuid4()) + "_" + file.filename
    file_location = os.path.join(upload_dir, file_name)

    # Append to the file instead of overwriting
    mode = "ab" if chunk_number > 0 else "wb"
    with open(file_location, mode) as file_object:
        contents = await file.read()
        file_object.write(contents)

    # Definir tamanho_arquivo como 0 por padrão
    tamanho_arquivo = 0

    # Lista para armazenar o texto extraído de cada página
    texto_paginas = []

    # Verifique se todos os chunks foram recebidos
    if chunk_number == total_chunks - 1:
        texto_extraido = "Texto extraído do arquivo PDF"
        informacoes_oficio = {"status": "Processado"}

        try:
            # Verificar se o arquivo PDF é válido
            with open(file_location, 'rb') as pdf_file:
                pdf_reader = PdfFileReader(pdf_file)
                if pdf_reader.numPages > 0:
                    # O arquivo PDF é válido, então extraia o texto de cada página
                    for page_num in range(pdf_reader.numPages):
                        pagina = pdf_reader.getPage(page_num)
                        texto_pagina = pagina.extract_text()
                        texto_paginas.append(texto_pagina)

                    # Extraia as informações do ofício
                    texto_extraido = '\n'.join(texto_paginas)
                    informacoes_oficio = extrair_informacoes_oficio(texto_extraido)
                    informacoes_oficio['texto_oficio'] = texto_extraido
                    informacoes_oficio['status_oficio'] = await tcu_upate_insert(informacoes_oficio)

                    # Obter o tamanho do arquivo
                    tamanho_arquivo = os.path.getsize(file_location)
                else:
                    return {"info": f"Arquivo '{file.filename}' inválido. Descartado."}

        except Exception as e:
            # Ocorreu um erro ao processar o arquivo PDF
            texto_extraido = f"Erro ao processar o arquivo PDF: {str(e)}"

        # Limpar - remover o arquivo temporário
        os.remove(file_location)

        return {
            "info": f"Arquivo '{file.filename}' processado com sucesso.",
            "nome_arquivo": file.filename,
            "tipo_conteudo": file.content_type,
            "tamanho_arquivo": tamanho_arquivo,
            "texto_paginas": texto_paginas,
            "informacoes_oficio": informacoes_oficio
        }

    return {"info": f"Chunk {chunk_number} do arquivo '{file.filename}' salvo temporariamente."}


@router.get("/apiptai/logo_rcm_ae")   
async def logo_rcm_ae():
    matriz_img =  "/code/app/chat.jpg"
    return FileResponse(matriz_img, media_type="image/png")

@router.get("/apiptai/logo_rcm_ae2")   
async def logo_rcm_ae2():
    matriz_img =  "/code/app/teste01.svg"
    return FileResponse(matriz_img, media_type="image/svg+xml")



@router.get("/apiptai/rcm_ae_participou/")
async def handle_click(request: Request, CD_RCM: str = None, utilidade: str = None):

    goto_url= "https://mefis.bb.com.br/apiptai/rcm_ae_participou/"    
    constants_sso = ConstantsSSO(goto_url)
    token = constants_sso.get_token(request)

    
    user_agent = request.headers.get("user-agent")
    print('user_agent ', user_agent, '--------')
    if "Outlook" in user_agent:
        origem_requisicao =  "Outlook"
    elif "Mozilla" in user_agent or "Chrome" in user_agent or "Safari" in user_agent:
        origem_requisicao =  "Browser"
    else:
        origem_requisicao =  "Outros"
        
    if isinstance(token, RedirectResponse):
        url = f"https://login.intranet.bb.com.br/distAuth/UI/Login?goto={goto_url}"
        return RedirectResponse(url) 
        
    elif isinstance(token, dict):
        data_hora_atual = datetime.now().strftime("%d/%m/%y - %H:%M")
        
        # Gerar o cabeçalho personalizado
        header = "/**********************************************************************************************************************************\n"
        header += f"<h1>Serviço auditoria - GA Refis!</h1><br> Obrigado pela contribuição! <br> ** {token.get('displayname')} em {data_hora_atual} ** <br> CD_RCM: {CD_RCM} <br> utilidade: {utilidade} <br><br> origem:{origem_requisicao}<br><br>\n"
        header += "*********************************************************************************************************************************/;\n"
       
        with open(os.path.join(DIR_FINAL, FILE_ACESSO), 'a') as f:
            # Escreva as variáveis na próxima linha do arquivo
            f.write(header)
            
    # Aqui você pode registrar o clique ou fazer qualquer outra ação necessária
    return HTMLResponse(header)

@router.get("/apiptai/rcm_ae_participou3/")
async def handle_click3(request: Request, CD_RCM: str = None, utilidade: str = None):
    goto_url = "https://mefis.bb.com.br/apiptai/rcm_ae_participou"
    constants_sso = ConstantsSSO(goto_url)
    token = constants_sso.get_token(request)
    
    if isinstance(token, RedirectResponse):
        url = f"https://login.intranet.bb.com.br/distAuth/UI/Login?goto={goto_url}"
        return RedirectResponse(url)
    
    elif isinstance(token, dict):
        data_hora_atual = datetime.now().strftime("%d/%m/%y - %H:%M")
        
        # Aqui você pode registrar o clique ou fazer qualquer outra ação necessária
        # Gerar o cabeçalho personalizado
        header = f"Serviço auditoria - GA Refis! Obrigado pela contribuição! {token.get('displayname')} em {data_hora_atual}. CD_RCM: {CD_RCM}, utilidade: {utilidade}"
        print(header)  # Ou faça o registro no banco de dados
    
    # Retorna uma resposta vazia ou uma resposta de sucesso
    return Response(status_code=200)

@router.post("/apiptai/rcm_ae_participou2/")
async def handle_click2(request: Request, CD_RCM: str = Form(...), utilidade: str = Form(...)):
    goto_url= "https://mefis.bb.com.br/apiptai/rcm_ae_participou/"    
    constants_sso = ConstantsSSO(goto_url)
    token = constants_sso.get_token(request)
    print('CD_RCM ', CD_RCM)
        
    if isinstance(token, RedirectResponse):
        url = f"https://login.intranet.bb.com.br/distAuth/UI/Login?goto={goto_url}"
        return RedirectResponse(url) 
        
    elif isinstance(token, dict):
        data_hora_atual = datetime.now().strftime("%d/%m/%y - %H:%M")
        
        # Gerar o cabeçalho personalizado
        header = "/**********************************************************************************************************************************\n"
        header += f"<h1>Serviço auditoria - GA Refis!</h1><br> Obrigado pela contribuição! <br> ** {token.get('displayname')} em {data_hora_atual} ** <br> CD_RCM: {CD_RCM} <br> utilidade: {utilidade} <br><br>\n"
        header += "*********************************************************************************************************************************/;\n"

    # Aqui você pode registrar o clique ou fazer qualquer outra ação necessária
    return HTMLResponse(header)

import json
from typing import List, Dict
from infra.sqlalchemy.config.database_pool import pool, execute_query # Importe o pool de database.py
from infra.sqlalchemy.repositorios.aux_txt_rcm import obter_textos
from infra.sqlalchemy.dao.apigpt import processar_texto_gpt_rcm_ae
import logging
logger = logging.getLogger(__name__)
import asyncio

import datetime

async def inserir_linha_rcm(
    relatorio: str,
    data_emissao: str,
    constatacoes: str,
    evidencias: str,
    recomendacao: str,
    instituicao_responsavel: str,
    prefixo_responsavel: str,
    instituicao_assunto_elbb: str,
    previsao_implementacao: str,
    matricula_do_gestor_responsavel: str,
    pdf_blob: bytes,
    relatorio_text_extract: str
):
    """
    Insere uma linha na tabela rcm.rcm_kpmg_relatorios com todas as colunas, inclusive o texto extraído do PDF.
    """
    query = """
    INSERT INTO rcm.rcm_kpmg_relatorios (
      relatorio,
      data_emissao,
      constatacoes,
      evidencias,
      recomendacao,
      instituicao_responsavel,
      prefixo_responsavel,
      instituicao_assunto_elbb,
      previsao_implementacao,
      matricula_do_gestor_responsavel,
      pdf_file,
      relatorio_text_extract
    ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
    RETURNING id;
    """
    result = await execute_query(
        query,
        relatorio,
        data_emissao,
        constatacoes,
        evidencias,
        recomendacao,
        instituicao_responsavel,
        prefixo_responsavel,
        instituicao_assunto_elbb,
        previsao_implementacao,
        matricula_do_gestor_responsavel,
        pdf_blob,
        relatorio_text_extract,
        return_one=True
    )
    if result:
        return result.get("id")
    return None

async def inserir_relatorio_rcm(
    nome: str,
    data_str: str,  # Recebe como string (ex.: '2024-09-20 00:00:00' ou '30-06-2025')
    constatacoes: str,
    recomendacoes: str,
    pdf_blob: bytes
):
    """
    Insere um relatório RCM no schema rcm, armazenando também o PDF como blob (bytea).
    Agora, a coluna 'data' da tabela rcm.rcm_kpmg_relatorios é do tipo TEXT, não date.
    """

    query = """
    INSERT INTO rcm.rcm_kpmg_relatorios (nome, data, constatacoes, recomendacoes, pdf_file)
    VALUES ($1, $2, $3, $4, $5)
    RETURNING id;
    """
    # Observe que na coluna 'data' estamos passando $2 (data_str) diretamente,
    # sem TO_DATE ou cast de data.

    result = await execute_query(
        query,
        nome,
        data_str,  # inserido como texto na coluna 'data'
        constatacoes,
        recomendacoes,
        pdf_blob,
        return_one=True
    )

    if result:
        return result.get('id')
    return None

async def inserir_linha_rcm(nome: str,
                            data_emissao: str,
                            constatacoes: str,
                            recomendacoes: str,
                            pdf_blob: bytes):
    """
    Insere 1 linha na tabela rcm.rcm_kpmg_relatorios,
    armazenando data_emissao como text e pdf_file como blob.
    """
    query = """
    INSERT INTO rcm.rcm_kpmg_relatorios (
       nome,
       data_emissao,
       constatacoes,
       recomendacoes,
       pdf_file
    ) VALUES ($1, $2, $3, $4, $5)
    RETURNING id;
    """
    result = await execute_query(
        query,
        nome,
        data_emissao,
        constatacoes,
        recomendacoes,
        pdf_blob,
        return_one=True
    )
    if result:
        return result.get("id")
    return None

async def inserir_linha_rcm(
    relatorio: str,
    data_emissao: str,
    constatacoes: str,
    evidencias: str,
    recomendacao: str,
    instituicao_responsavel: str,
    prefixo_responsavel: str,
    instituicao_assunto_elbb: str,
    previsao_implementacao: str,
    matricula_do_gestor_responsavel: str,
    pdf_blob: bytes,
    relatorio_text_extract: str
):
    """
    Insere uma linha na tabela rcm.rcm_kpmg_relatorios com todas as colunas, inclusive o texto extraído do PDF.
    """
    query = """
    INSERT INTO rcm.rcm_kpmg_relatorios (
      relatorio,
      data_emissao,
      constatacoes,
      evidencias,
      recomendacao,
      instituicao_responsavel,
      prefixo_responsavel,
      instituicao_assunto_elbb,
      previsao_implementacao,
      matricula_do_gestor_responsavel,
      pdf_file,
      relatorio_text_extract
    ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
    RETURNING id;
    """
    result = await execute_query(
        query,
        relatorio,
        data_emissao,
        constatacoes,
        evidencias,
        recomendacao,
        instituicao_responsavel,
        prefixo_responsavel,
        instituicao_assunto_elbb,
        previsao_implementacao,
        matricula_do_gestor_responsavel,
        pdf_blob,
        relatorio_text_extract,
        return_one=True
    )
    if result:
        return result.get("id")
    return None


async def get_opcoes_rcm(servico):
    json_results = {}
    
    # Utilizando a função execute_query para realizar as consultas ao banco de dados
    ctgr_dmd_query_result = await execute_query("SELECT DISTINCT cd_ctgr_dmd_ocr, tx_ctgr_dmd FROM riscometro.rcm_status_atual;")
    json_results['ctgr_dmd'] = [{'code': int(code), 'name': name} for code, name in ctgr_dmd_query_result.items()]

    est_rcm_query_result = await execute_query("SELECT DISTINCT cd_tip_est_rcm, situacao_rcm FROM riscometro.rcm_status_atual;", return_one=False)
    json_results['est_rcm'] = [{'code': int(code), 'name': name} for code, name in est_rcm_query_result.items()]

    # Obter a data máxima
    dt_ems_rcm_max_query_result = await execute_query("SELECT MAX(dt_ems_rcm) AS dt_ems_rcm_max FROM riscometro.rcm_status_atual;", return_one=True)
    json_results['dt_ems_rcm_max'] = dt_ems_rcm_max_query_result.get('dt_ems_rcm_max', None)

    # Obter a data mínima
    dt_ems_rcm_min_query_result = await execute_query("SELECT MIN(dt_ems_rcm) AS dt_ems_rcm_min FROM riscometro.rcm_status_atual;", return_one=True)
    json_results['dt_ems_rcm_min'] = dt_ems_rcm_min_query_result.get('dt_ems_rcm_min', None)

    ano_ems_rcm_query_result = await execute_query("SELECT DISTINCT CAST(ano_ems_rcm AS INTEGER) AS code, CAST(ano_ems_rcm AS VARCHAR) AS name FROM riscometro.rcm_status_atual ORDER BY code DESC;", return_one=False)
    ano_ems_rcm_formatted = [{"code": int(code), "name": name} for code, name in ano_ems_rcm_query_result.items()]
    json_results['ano_ems_rcm'] = ano_ems_rcm_formatted

    json_results['ga_coord'] = await execute_query("SELECT distinct  cd_ga_coord as code, nm_ga_coord as name FROM ptai.ptai_trabalhos;")
    #json_results['ga_coord'] = [{'code': int(code), 'name': name} for code, name in ctgr_dmd_query_result.items()]




    json_results['gpt_offline'] = obter_textos()
    
    return json_results


def converter_para_latin1(input_str): 
    # Codifica a string como LATIN1, substituindo caracteres que não têm equivalente por '?' 
    return input_str.encode('latin1', 'replace').decode('latin1')

def substituir_aspas_por_espaco(texto):
    """
    Substitui as aspas simples por espaços no texto.
    """
    return texto.replace("'", " ")

async def tcu_upate_insert(informacoes):
    informacoes = {k: substituir_aspas_por_espaco(v) if isinstance(v, str) else v for k, v in informacoes.items()} # 
    
    informacoes_latin1 = {k: converter_para_latin1(v) if isinstance(v, str) else v for k, v in informacoes.items()} # 
 
    #informacoes['oficio'] = informacoes['oficio'].strip()
    query = f"SELECT distinct * FROM tcu.oficio_tcu WHERE oficio = '{informacoes['oficio']}'"
    
    record = await  execute_query(query)
    status = ""
    if record: 
        query = f"""
                UPDATE tcu.oficio_tcu
                SET processo = '{informacoes['processo']}' ,
                data = '{informacoes['data']}',
                tipo_processo = '{informacoes['tipo_processo']}',
                assunto = '{informacoes['assunto']}',
                solicitacao = '{informacoes_latin1['solicitacao']}',
                texto_oficio = '{informacoes_latin1['texto_oficio']}',
                acordao = '{informacoes_latin1['acordao']}',
                despacho= '{informacoes_latin1['despacho']}',
                informacoes_adicionais = '{informacoes_latin1['informacoes_adicionais']}',
                proposta_encaminhamento = '{informacoes_latin1['proposta_encaminhamento']}',
                conclusao = '{informacoes_latin1['conclusao']}',
                introducao = '{informacoes_latin1['introducao']}',
                admissibilidade = '{informacoes_latin1['admissibilidade']}',
                exame_tecnico = '{informacoes_latin1['exame_tecnico']}'

                WHERE oficio =  '{informacoes['oficio']}';
                """
        status = "Atualizado"
        await execute_query(query)
    else:
        query = f"""
                INSERT INTO tcu.oficio_tcu
                (oficio, processo, "data", tipo_processo, 
                assunto, solicitacao, texto_oficio, 
                conclusao, informacoes_adicionais, proposta_encaminhamento, 
                acordao, despacho, introducao, admissibilidade, exame_tecnico)
                VALUES('{informacoes['oficio']}', '{informacoes['processo']}', '{informacoes['data']}', '{informacoes['tipo_processo']}', 
                       '{informacoes['assunto']}', '{informacoes_latin1['solicitacao']}', '{informacoes_latin1['texto_oficio']}',
                       '{informacoes_latin1['conclusao']}', '{informacoes_latin1['informacoes_adicionais']}', 
                       '{informacoes_latin1['proposta_encaminhamento']}', '{informacoes_latin1['acordao']}', '{informacoes_latin1['despacho']}', 
                       '{informacoes_latin1['introducao']}', '{informacoes_latin1['admissibilidade']}', '{informacoes_latin1['exame_tecnico']}');
                """
        status = "Inserido"
        await execute_query(query)
    return status


# modelos de buscas
async def buscar_oficios_tcu():
    query = """
    SELECT * FROM tcu.oficio_tcu;
    """
    return await execute_query(query)
    


async def fetch_all(query, params=None):
    return await execute_query(query)
    
# Função rcm_ae_update (assumindo que é uma função assíncrona)
async def rcm_ae_update(cd_rcm):
    # Implemente a lógica de atualização aqui
    
    #txt_gpt = apicainfgpt('Novo resumo atualizado')
    #resumo_text, classificacao_dict, json_obj = processar_texto_gpt_rcm_ae(txt_gpt)
    
    resumo_gpt = '''
    O texto aborda um relatório de Auditoria Externa da Deloitte, especificamente relacionado à área Digov do Fundo de Parcerias Público-Privadas (FPPP). O documento, datado de 31/12/2022, discute a necessidade de aprimoramento e implementação de controles internos. O objetivo é assegurar que os prazos normatizados para o pagamento de honras de avais sejam devidamente cumpridos, indicando uma preocupação com a eficiência e conformidade dos processos internos. 
    '''
    
    txt_gpt = '''[{'tipo': 'Auditoria de Tecnologia da Informação', 'resposta': 'NÃO', 'justificativa': 'O texto não menciona qualquer termo ou contexto relacionado à Auditoria de Tecnologia da Informação.'}, {'tipo': 'Impostos', 'resposta': 'NÃO', 'justificativa': 'O texto não menciona qualquer termo ou contexto relacionado a Impostos.'}, {'tipo': 'Previdência', 'resposta': 'NÃO', 'justificativa': 'O texto não menciona qualquer termo ou contexto relacionado a Previdência.'}, {'tipo': 'Consórcio', 'resposta': 'NÃO', 'justificativa': 'O texto não menciona qualquer termo ou contexto relacionado a Consórcio.'}]
    '''
    
    update_query = f"""
    UPDATE riscometro.rcm_status_atual
    SET  txt_gpt = '{txt_gpt}''
    WHERE cd_rcm = '{cd_rcm}';
    """
    await execute_query(update_query)
    
async def acoes_gerais_dao(servico):
    if servico['acao'] == 'remover_oficio':
        query_delecao = f"""
        DELETE FROM tcu.oficio_tcu
        WHERE oficio = '{servico['variavel']}';
        """
        await execute_query(query_delecao)

        # Após a remoção, buscar a lista atualizada
        query_lista_atualizada = "SELECT * FROM tcu.oficio_tcu;"
        results = await fetch_all(query_lista_atualizada)
        return results
    
    if servico['acao'] == 'rcm_ae_gpt':
        query_lista_atualizada = f"""
        SELECT cd_rcm, tx_gpt, resumo_gpt, classificacao_dict, resumo_gpt, txt_gpt
        FROM rcm.rcm_ae
        WHERE cd_rcm = '{servico['cd_rcm']}';
        """
        results = await fetch_all(query_lista_atualizada)
        
        # # Verificar se o resumo é nulo e chamar a função rcm_ae_update se necessário
        if results and results[0]['txt_gpt'] is None:
            await rcm_ae_update(servico['cd_rcm'])
        #     # Buscar os resultados atualizados após a atualização
            results = await fetch_all(query_lista_atualizada)
        
        # return results
        
        #json_obj = processar_texto_gpt_rcm_ae('txt_gpt')
        #return json_obj
        return results
    
async def get_last_root_key_old():
    query = """
    SELECT key 
    FROM processos.directory_items 
    WHERE parent_key IS NULL
    ORDER BY CAST(key AS INTEGER) DESC
    LIMIT 1;
    """
    result = await execute_query(query, return_one=True)
    return int(result['key']) if result else 0  # type: ignore # Se não houver raízes, retorna 0 como base

async def get_last_subitem_key_old(parent_key: str):
    query = """
    SELECT key 
    FROM processos.directory_items
    WHERE parent_key = $1
    ORDER BY CAST(SUBSTRING(key FROM '[0-9]+$') AS INTEGER) DESC
    LIMIT 1;
    """
    result = await execute_query(query, parent_key, return_one=True)
    
    if result is None:
        return f"{parent_key}-0"  # Se não houver subitens, retorna o primeiro subitem
    
    base_key = result['key'].rsplit('-', 1)[0] # type: ignore
    last_number = int(result['key'].split('-')[-1]) # type: ignore
    
    return f"{base_key}-{last_number + 1}"

async def insert_directory_item_old(label, data, icon, parent_key=None, is_folder=True, url_painel=None, tx_painel=None):
    # Verifica se um item com as mesmas propriedades já existe (sem verificar url_painel e tx_painel)
    check_duplicate_query = """
    SELECT id, key 
    FROM processos.directory_items 
    WHERE label = $1 
    AND parent_key IS NOT DISTINCT FROM $2
    AND icon = $3
    AND COALESCE(data, '') = COALESCE($4, '')
    AND is_folder = $5
    LIMIT 1;
    """

    existing_item = await execute_query(check_duplicate_query, label.strip(), parent_key, icon.strip(), data.strip() if data else None, is_folder, return_one=True)
    
    if existing_item:
        logger.info(f"Item com label '{label}' já existe no diretório com id {existing_item['id']}, inserção ignorada.")
        return existing_item['id'], existing_item['key']  # Retorna o ID e a key existente para evitar inserção
    
    # Gerar um novo 'key' se não foi passado
    if parent_key is None:
        last_root_key = await get_last_root_key()
        key = str(last_root_key + 1)
    else:
        key = await get_last_subitem_key(parent_key)

    # Inserir o novo item
    insert_query = """
    INSERT INTO processos.directory_items (key, parent_key, label, data, icon, is_folder, url_painel, tx_painel)
    VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
    RETURNING id, key;
    """
    
    result = await execute_query(insert_query, key, parent_key, label.strip(), data.strip() if data else None, icon.strip(), is_folder, url_painel, tx_painel, return_one=True)
    new_id = result['id'] # type: ignore
    new_key = result['key'] # type: ignore
    
    logger.info(f"Novo item adicionado com id {new_id} e key {new_key}")
    return new_id, new_key


async def remove_directory_item_cascade_old(key: str):
    delete_items_query = """
    WITH RECURSIVE children AS (
        SELECT key FROM processos.directory_items WHERE key = $1
        UNION ALL
        SELECT d.key FROM processos.directory_items d
        JOIN children c ON d.parent_key = c.key
    )
    DELETE FROM processos.directory_items
    WHERE key IN (SELECT key FROM children);
    """
    
    await execute_query(delete_items_query, key)
    logger.info(f"Item com key {key} e seus filhos foram removidos com sucesso!")
    
async def update_item_in_directory(key: str, data: dict):
    fields = []
    values = [key]

    #data_edicao = datetime.datetime.now()
    #values.append(data_edicao)
    fields.append("data_edicao = NOW()")

    for i, (field, value) in enumerate(data.items(), start=2):
        fields.append(f"{field} = ${i}")
        values.append(value)

    if not fields:
        return False

    update_query = f"""
    UPDATE processos.directory_items
    SET {', '.join(fields)}
    WHERE key = $1
    RETURNING id;
    """
    print('update_query ', )

    result = await execute_query(update_query, *values, return_one=True)
    return result is not None


async def get_last_root_key():
    query = """
    SELECT key 
    FROM processos.directory_items 
    WHERE parent_key IS NULL
    ORDER BY CAST(key AS INTEGER) DESC
    LIMIT 1;
    """
    result = await execute_query(query, return_one=True)
    return int(result['key']) if result else 0  # type: ignore # Se não houver raízes, retorna 0 como base

async def get_last_subitem_key(parent_key: str):
    query = """
    SELECT key 
    FROM processos.directory_items
    WHERE parent_key = $1
    ORDER BY CAST(SUBSTRING(key FROM '[0-9]+$') AS INTEGER) DESC
    LIMIT 1;
    """
    result = await execute_query(query, parent_key, return_one=True)
    
    if result is None:
        return f"{parent_key}-0"  # Se não houver subitens, retorna o primeiro subitem
    
    base_key = result['key'].rsplit('-', 1)[0] # type: ignore
    last_number = int(result['key'].split('-')[-1]) # type: ignore
    
    return f"{base_key}-{last_number + 1}"

async def insert_directory_item(label, data, icon, parent_key=None, is_folder=True, url_painel=None, tx_painel=None):
    # Verifica se um item com as mesmas propriedades já existe (sem verificar url_painel e tx_painel)
    check_duplicate_query = """
    SELECT id, key 
    FROM processos.directory_items 
    WHERE label = $1 
    AND parent_key IS NOT DISTINCT FROM $2
    AND icon = $3
    AND COALESCE(data, '') = COALESCE($4, '')
    AND is_folder = $5
    LIMIT 1;
    """

    existing_item = await execute_query(check_duplicate_query, label.strip(), parent_key, icon.strip(), data.strip() if data else None, is_folder, return_one=True)
    
    if existing_item:
        logger.info(f"Item com label '{label}' já existe no diretório com id {existing_item['id']}, inserção ignorada.")
        return existing_item['id'], existing_item['key']  # Retorna o ID e a key existente para evitar inserção
    
    # Gerar um novo 'key' se não foi passado
    if parent_key is None:
        last_root_key = await get_last_root_key()
        key = str(last_root_key + 1)
    else:
        key = await get_last_subitem_key(parent_key)

    # Inserir o novo item
    insert_query = """
    INSERT INTO processos.directory_items (key, parent_key, label, data, icon, is_folder, url_painel, tx_painel, data_cadastramento)
    VALUES ($1, $2, $3, $4, $5, $6, $7, $8, NOW() )
    RETURNING id, key;
    """
    
    result = await execute_query(insert_query, key, parent_key, label.strip(), data.strip() if data else None, icon.strip(), is_folder, url_painel, tx_painel, return_one=True)
    new_id = result['id'] # type: ignore
    new_key = result['key'] # type: ignore
    
    logger.info(f"Novo item adicionado com id {new_id} e key {new_key}")
    return new_id, new_key


async def remove_directory_item_cascade(key: str):
    delete_items_query = """
    WITH RECURSIVE children AS (
        SELECT key FROM processos.directory_items WHERE key = $1
        UNION ALL
        SELECT d.key FROM processos.directory_items d
        JOIN children c ON d.parent_key = c.key
    )
    DELETE FROM processos.directory_items
    WHERE key IN (SELECT key FROM children);
    """
    
    await execute_query(delete_items_query, key)
    logger.info(f"Item com key {key} e seus filhos foram removidos com sucesso!")
    
async def get_directory_structure():
    select_query = """
    SELECT key, parent_key, label, data, icon, is_folder, url_painel, tx_painel 
    FROM processos.directory_items 
    ORDER BY key;
    """
    
    items = await execute_query(select_query)
    return items

def build_tree(items):
    nodes = {}
    
    # Criando nós a partir dos itens
    for item in items:
        node = {
            'key': item['key'],
            'label': item['label'],
            'data': item['data'],
            'icon': item['icon'],
            'is_folder': item['is_folder'],
            'url_painel': item['url_painel'] if 'url_painel' in item else '',
            'tx_painel': item['tx_painel'] if 'tx_painel' in item else '', 
            'children': []
        }
        nodes[item['key']] = node

    # Atribuindo os filhos aos pais
    tree = []
    for item in items:
        parent_key = item['parent_key']
        if parent_key:
            nodes[parent_key]['children'].append(nodes[item['key']])
        else:
            tree.append(nodes[item['key']])

    return tree


async def chat_trabalhos(ano: int):
    """
    Executa a consulta SQL usando o parâmetro ano_fim_real.
    """
    query = f"""
    SELECT DISTINCT nr_trabalho, nm_trab
    FROM destaques.gpt_destaques where ano = {ano} or nr_trabalho = 49575
    ;
    """
    return await execute_query(query)

async def chat_trabalho(nr_trabalho: int):
    query = f"""
    SELECT DISTINCT  
           nr_trabalho, 
           titulo, 
           nr_trabalho, 
           ano, 
           nm_trab, 
           obj_trab, 
           manchete_html, 
           materia_html, 
           rel_hash, 
           pontos_positivo_html, 
           pontos_aprimorar_html, 
           materialidade_html,
           dt_movimento,
           
           CONCAT(
               'Você é um assistente especializado em auditoria interna. Sua tarefa é analisar as informações fornecidas sobre um ',
               'trabalho de auditoria e gerar um Destaque de Auditoria seguindo as diretrizes estabelecidas. ',
               
               '\\n\\nDefinição de Destaque de Auditoria: ',
               'Um Destaque de Auditoria são informações de valor agregado, relevantes e úteis, descritas sob a forma de pequenas ',
               'manchetes. Eles podem se referir à identificação e mitigação de constatações significativas ou a melhorias de ',
               'processos implementadas pelos gestores. Destinam-se ao Conselho de Administração (CA), Conselho Fiscal (CF), ',
               'Coadutoria (Coaud) e Conselho de Diretoria (CD). Deve apresentar uma visão sistêmica, linguagem jornalística, ',
               'ordem direta, sem tecnicismos, coerência com os eventos de risco avaliados, e alinhamento com a materialidade ',
               'e criticidade das recomendações.',

               '\\n\\nEstrutura dos Dados da Auditoria: ',
               'Os dados fornecidos para análise estão estruturados da seguinte forma:',
               '- [trabalho]: Número do trabalho. ',
               '- [objetivo trabalho]: Objetivo do trabalho. ',
               '- [justificativa trabalho]: Justificativa do trabalho. ',
               '- [eventos de riscos avaliados]: Eventos de riscos avaliados. ',
               '- [relatorio auditoria]: Relatório de auditoria. ',
               '- [principal constatação no relatorio]: Principal constatação do relatório. ',
               '- [ocorrência e evidencia de achados de auditoria]: Ocorrências e evidências de achados de auditoria. ',
               '- [recomendações]: Recomendações.',

               '\\n\\nCritérios para Identificar Relevância: ',
               '- Eventos de Risco Críticos: Priorizar eventos avaliados com notas 4 e 5 em [eventos de riscos avaliados]. ',
               '- Recomendações Relevantes: Priorizar recomendações com criticidade \"A\" e \"B\" em [recomendações]. ',
               '- Ocorrências e Evidências Significativas: Identificar as evidências e ocorrências mais relevantes em [ocorrência e evidencia de achados de auditoria]. ',

               '\\n\\nDados da Auditoria: ',
               'trabalho: ', nr_trabalho,
               ' | objetivo trabalho: ', obj_trab, 
               ' | eventos de riscos avaliados: ', evento_rsco_avaliado,
               ' | relatorio auditoria: ', tx_rel_atvd,  
               ' | principal constatação no relatorio: ', tx_constatacao, 
               ' | recomendações: ', rcm_concat,

               '\\n\\nA partir de agora, você participará de um chat em que o auditor poderá fazer perguntas sobre o trabalho de auditoria, incluindo detalhes como recomendações, principais constatações do relatório e pontos de atenção. ',
               'É fundamental que suas respostas sejam consistentes, diretas e baseadas nos dados fornecidos. ',
               'Evite pedidos de desculpas ou tentativas de adequação desnecessárias. ',
               'Caso seja questionado por que um ponto específico não foi incluído como recomendação ou destaque, explique o raciocínio por trás da decisão com base nos critérios de relevância e criticidade. ',
               'Sempre que possível, reforce a lógica usada para gerar os destaques e justifique sua análise. ',
               
               '\\n\\n**Importante**: ',
               '- Suas respostas devem ter no máximo ~800 caracteres, em até dois parágrafos. ',
               '- Se a pergunta ultrapassar o escopo dos dados fornecidos ou não tiver relação alguma com auditoria, você deve se recusar a responder ou informar gentilmente que não pode ajudar nesse tema. ',
               '- Mantenha-se dentro do contexto do trabalho de auditoria em questão. ',
               '- Não use informações que não estejam no texto fornecido ou que não sejam relacionadas diretamente à auditoria. '
           ) AS role_user,

           CONCAT(
               'Segue minha análise: ',
               ' pontos_positivo: ', pontos_positivo, 
               ' pontos_aprimorar: ', pontos_aprimorar, 
               ' materialidade: ', materialidade
           ) AS role_assistant

    FROM destaques.gpt_destaques
    WHERE nr_trabalho = {nr_trabalho};
    """
    return await execute_query(query)


    
async def salvar_mensagem(mensagem):
    """
    Insere uma mensagem no banco de dados no formato fornecido.
    
    Args:
        mensagem (Mensagem): Dados da mensagem.
    """
    query = f"""
        INSERT INTO destaques.chat_destaques (
            numero_trabalho, matricula, sessao, remetente, conteudo
        ) VALUES (
            '{mensagem.numero_trabalho}', '{mensagem.matricula}', '{mensagem.sessao}', 
            '{mensagem.remetente}', '{mensagem.conteudo}'
        );
    """
    try:
        await execute_query(query)
        logger.info("Mensagem salva com sucesso.")
        return "Inserido"
    except Exception as e:
        logger.error(f"Erro ao salvar mensagem: {e}")
        return "Erro"

async def salvar_feedback(feedback):
    """
    Insere um feedback no banco de dados.
    """
    query = f"""
        INSERT INTO destaques.feedback_destaques (
            texto, matricula, trabalho, sessao, feedback, agente, objetoaudt
        ) VALUES (
            '{feedback.texto}', 
            '{feedback.matricula}', 
            {feedback.trabalho}, 
            '{feedback.sessao}', 
            '{feedback.feedback}',
            '{feedback.agente}', 
            '{feedback.objetoaudt}'
            
        );
    """
    try:
        await execute_query(query)
        logger.info("Feedback salvo com sucesso.")
        return "Inserido"
    except Exception as e:
        logger.error(f"Erro ao salvar feedback: {e}")
        raise e


async def salvarChatGeral(mensagem):
    """
    Insere dados na tabela chat_geral usando parâmetros seguros.
    """
    query = """
        INSERT INTO destaques.chat_geral (
            objeto_auditoria, sessao, remetente, conteudo, matricula
        ) VALUES (
            '{mensagem.objeto_auditoria}', '{mensagem.sessao}', '{mensagem.remetente}', '{mensagem.conteudo}', '{mensagem.matricula}'
        )
    """
    
    try:
        await execute_query(query) 
        logger.info("Registro iteração salvo com sucesso.")
        return "Inserido"
    except Exception as e:
        logger.error(f"Erro ao salvar registro: {e}")
        return "Erro"


async def chat_geral_query(data):
    query = '' 

    if  data.get("agente") =='exterior' and data.get("param1") =='relindividual':
        
        query = f"""SELECT nr_trabalho, CONCAT(
                'Você é um assistente especializado em auditoria interna do Banco do Brasil. A seguir, há informações sobre o trabalho de auditoria: ',

                '\n\n[1] Resumo em português do relatório (resumo_pt_trabalho): ', resumo_pt_trabalho,
                '\n[2] Objetivo do trabalho (PT) (traducao_objetivo_trabalho): ', traducao_objetivo_trabalho,
                '\n[3] Justificativa do trabalho (PT) (traducao_justificativa_trabalho): ', traducao_justificativa_trabalho,
                '\n[4] Recomendações criticidade A/B (resumo_rcm_5_crit_a_b_mais_relevante): ', resumo_rcm_5_crit_a_b_mais_relevante,
                '\n[5] Principais constatações (resumo_pt_principais_constatacao): ', resumo_pt_principais_constatacao,

                '\n\n--------------------------------------------------',
                '\n[TEXTO COMPLETO - combined_text]:\n',
                combined_text,

                '\n\nAgora, você pode fazer perguntas específicas sobre qualquer ponto acima, seja algo dos resumos já criados ou informações detalhadas do relatório completo.', 
                'Seja objetivo, foque no essencial e garanta que o texto consolidado não ultrapasse 3.500 tokens no total.'
            ) AS role_user,
            CONCAT(
                'Olá! Estou pronto para responder suas dúvidas sobre o Trabalho de Auditoria n ',
                nr_trabalho,
                '. Fique à vontade para perguntar!'
            ) AS role_assistant


        FROM exterior.gpt_agil_relatorio_ex where nr_trabalho = {int(data.get("param2"))};
        """

    elif  data.get("agente") =='exteriorconsolidado' and data.get("param1") =='relconsolidado':
        
        query = f"""SELECT
            cd_ga_coord,
            ano_fim_real,
            CONCAT(
                'Você é um assistente especializado em auditoria interna do Banco do Brasil. A seguir, há um panorama consolidado ',
                'dos pontos mais relevantes para a Coordenação ', cd_ga_coord, ' no exercício ', ano_fim_real, '.',

                '\n\n[1] Resumo dos pontos mais relevantes (resumo_pt_relatorios):\n',
                resumo_pt_relatorios,

                '\n\n[2] Principais constatações (resumo_pt_principais_constatacao):\n',
                resumo_pt_principais_constatacao,

                '\n\n[3] Alerta executivo (alerta_executivo_rel), caso exista algo extremamente grave:\n',
                alerta_executivo_rel,

                '\n\n[4] Principais recomendações do exercício (resumo_rcm_mais_relevante_exercicio), ',
                'considerando criticidade A e B:\n',
                resumo_rcm_mais_relevante_exercicio,

                '\n\n[5] Resumo dos pontos positivos (resumo_pt_relatorios_positivo):\n',
                resumo_pt_relatorios_positivo,

                '\n\n[6] Principais constatações positivas (resumo_pt_principais_constatacao_positivo):\n',
                resumo_pt_principais_constatacao_positivo,

                '\n\n[7] Alerta executivo positivo (alerta_executivo_positivo):\n',
                alerta_executivo_positivo,

                '\n\n--------------------------------------------------',
                '\n[TEXTO CONSOLIDADO COMPLETO - combined_text]:\n',
                combined_text,

                '\n\n**Observação Importante**:\n',
                'Este chat responde perguntas sobre os **pontos consolidados** das auditorias desta Coordenação/Exercício. ',
                'Se necessitar de **detalhes específicos** de algum Trabalho de Auditoria (por ex.: recomendações detalhadas, ',
                'justificativa, relatórios completos), é preciso acessar o agente específico do respectivo trabalho, ',
                'pois lá há todo o relatório em profundidade.',
                'Seja objetivo, foque no essencial e garanta que o texto consolidado não ultrapasse 3.500 tokens no total.'
            ) AS role_user,
            CONCAT(
                'Olá! Estou pronto para responder suas dúvidas sobre a Coordenação ',
                cd_ga_coord,
                ' do ano de ', ano_fim_real, 
                '. Sinta-se à vontade para perguntar!'
            ) AS role_assistant

        FROM exterior.gpt_relatorio_ex_consolidado
        WHERE cd_ga_coord = {int(data.get("param2"))}
        AND ano_fim_real ={int(data.get("param3"))};
        """
   
    elif  data.get("agente") =='atb' and data.get("param1") =='plntrabalhos':
        
        query1 = f"""SELECT DISTINCT 
            t1.nr_trabalho, 
            t1.in_abgc_elbb, 
            t1.dt_inc_dmd, 
            t1.dt_fin_dmd, 
            t1.dt_inc_plnj,
            t1.dt_fim_plnj AS data_fim_planejamento_atual, 
            t1.p_dt_fim_plnj AS data_fim_planejamento_paint,
            EXTRACT(YEAR FROM t1.dt_fim_plnj) AS ano_fim_planejamento_atual, 
            EXTRACT(YEAR FROM t1.p_dt_fim_plnj) AS ano_fim_planejamento_paint,
            t1.nm_trab, 
            t1.obj_trab, 
            t1.cd_tip_atvd_plnj, 
            t1.nm_tip_atvd_plnj, 
            /*
            t1.cd_tip_est_atvd, 
            t1.nm_tip_est_atvd, 
            */
            t1.nm_tip_est_atvd,
            t1.nr_trabalho_pln, 
            t1.pln_alteracoes, 
            t1.pln_cancelamentos
        FROM 
            atb.trabalhos_simulado AS t1;
                """  
        
        query2 = f"""
                WITH pln_anual AS (
            SELECT 
                LPAD(mes::text, 2, '0') || '/' || ano::text AS mes_ano_conclusao, 
                semestre, 
                mes, 
                ano, 
                qtd_prevista, 
                acc_qtd_prevista, 
                meta, 
                semestre_ano_ref, 
                qtd_rlz, 
                acc_qtd_realizado
            FROM 
                atb.pln_anual_full 
            WHERE 
                ano = 2025
        ),
        trabalhos_simulado AS (
            SELECT
                mes_ano,
                COUNT(nr_trabalho) AS quantidade,
                SUM(COUNT(nr_trabalho)) OVER (ORDER BY MIN(dt_fim_plnj)) AS acumulado
            FROM (
                SELECT
                    nr_trabalho,
                    dt_fim_plnj,
                    TO_CHAR(dt_fim_plnj, 'MM/YYYY') AS mes_ano
                FROM 
                    atb.trabalhos_simulado
                WHERE 
                    cd_tip_est_atvd != 9 and cd_tip_est_atvd !=22
                    AND EXTRACT(YEAR FROM dt_fim_plnj) = 2025
            ) AS subquery
            GROUP BY 
                mes_ano
            ORDER BY 
                MIN(dt_fim_plnj)
        )
        SELECT 
            p.mes_ano_conclusao, 
            p.semestre, 
            p.mes, 
            p.ano, 
            p.qtd_prevista as orcado_mensal, 
            p.acc_qtd_prevista orcado_acumulado, 
            t.quantidade as qtd_prevista,
            t.acumulado as qtd_prevista_acumulado,
            p.meta
        FROM 
            pln_anual p
        LEFT JOIN 
            trabalhos_simulado t
        ON 
            p.mes_ano_conclusao = t.mes_ano  ;
        """
        result1 = await execute_query(query1)
        result2 = await execute_query(query2)

        # Retornar os resultados separadamente
        return result1, result2

    elif data.get("agente") == 'rcmkpmg' and data.get("param1") == 'individual':
        print('>>>>>> rcmkpmg <<<<<<')
        query = f"""
        SELECT 
            relatorio_text_extract, 
            "relatorio", 
            "constatacoes", 
            "evidencias", 
            "recomendacao", 
            "prefixo_responsavel", 
            "instituicao_assunto_elbb", 
            "previsao_implementacao", 
            "matricula_do_gestor_responsavel",
            CONCAT(
                'Você receberá um relatório de auditoria externa: ', relatorio_text_extract,
                '\n\nQuero que você analise se nesse relatório tem o registro dessa constatação: ', constatacoes, 
                ' e esta recomendação: ', recomendacao, 
                '\nCaso encontre a constatação ou a recomendação, informe a página ou dê uma dica de onde está para facilitar a visualização do funcionário.', 
                '\nInformar se a data de implementação na constatação é ', PREVISAO_IMPLEMENTACAO, 
                '\n\n**Atenção: Todas as informações utilizadas devem ser rigorosamente obtidas dos dados fornecidos, sem criar, complementar ou inserir informações extras.**',
                '\n\n2. **Retornar o resultado no seguinte formato JSON:**\n\n',
                '{{\n',
                '    "achou_constatacao": "Sim/Não",\n',
                '    "achou_recomendacao": "Sim/Não",\n',
                '    "dica_localizar_constatacao": "caso encontre a constatação ou a recomendação, informe a página ou dê uma dica de onde está para facilitar a visualização do funcionário",\n',
                '    "dica_localizar_recomendacao": "caso encontre a constatação ou a recomendação, informe a página ou dê uma dica de onde está para facilitar a visualização do funcionário",\n',
                '    "conf_implementacao": "Correta, sim ou não",\n',
                '    "racional": "Racional por que considera que o achado foi regularizado durante o trabalho, incluindo a declaração explícita do auditor ou explicação do porquê não foi encontrado",\n',
                '    "resumo_constatacao": "Resumo da constatação",\n',
                '    "resumo_recomendacao": "Resumo da recomendação"\n',
                '}}'
            ) AS role_user,
            CONCAT(
                'Olá! Estou pronto para responder suas dúvidas sobre o relatório de auditoria externa. ',
                'Por favor, forneça informações rigorosamente obtidas dos dados fornecidos, sem criar, complementar ou inserir informações extras.'
            ) AS role_assistant
        FROM 
            rcm.rcm_kpmg_relatorios 
        WHERE 
            id = {int(data.get("param2"))};
        """

        print('query ', query)

    else:
        query=''

        
    return await execute_query(query)

import { Component, ViewChild, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FileUpload, FileUploadModule } from 'primeng/fileupload';
import { ButtonModule } from 'primeng/button';
import { MessageService, MenuItem } from 'primeng/api';
import { ToastModule } from 'primeng/toast';
import { TableModule } from 'primeng/table';
import { StepsModule } from 'primeng/steps';
import { RouterModule } from '@angular/router';
import * as XLSX from 'xlsx';
import { ServicoLLMService } from '../servico-llm.service';

export interface RcmRelatorio {
  id: number;
  relatorio: string;
  data_emissao: string | null;
  constatacoes: string;
  recomendacoes: string;
}

@Component({
  selector: 'app-rcmexcel',
  standalone: true,
  imports: [
    CommonModule,
    FileUploadModule,
    ButtonModule,
    ToastModule,
    TableModule,
    StepsModule, RouterModule
  ],
  providers: [ServicoLLMService, MessageService],
  templateUrl: './rcmrelatorio.component.html',
  styleUrls: ['./rcmrelatorio.component.css']
})
export class RcmrelatorioComponent implements OnInit {
  excelFile: File | null = null;
  pdfFiles: File[] = [];
  relatoriosExcel: string[] = [];
  rcmRelatorios: RcmRelatorio[] = [];

  @ViewChild('excelUploader') excelUploader!: FileUpload;
  @ViewChild('pdfUploader') pdfUploader!: FileUpload;

  lastUploadedExcel: string | null = null;
  lastUploadedPdfs: string[] = [];

  steps: MenuItem[] = [];
  activeStep: number = 0;

  colunasObrigatorias = [
    'RELATORIO',
    'DATA_EMISSAO',
    'CONSTATACAO',
    'EVIDENCIAS',
    'RECOMENDACAO',
    'INSTITUICAO_RESPONSAVEL',
    'PREFIXO_RESPONSAVEL',
    'INSTITUICAO_ASSUNTO_ELBB',
    'PREVISAO_IMPLEMENTACAO',
    'MATRICULA_DO_GESTOR_RESPONSAVEL'
  ];

  constructor(
    private messageService: MessageService,
    private servicoLLM: ServicoLLMService
  ) {}

  ngOnInit() {
    this.steps = [
      { label: 'Excel KPMG' },
      { label: 'Selecione os Relatórios' },
      { label: 'Upload Recomendações KPMG' }
    ];
    this.getRmcKpmg();
  }

  get pdfFilesNames(): string {
    return this.pdfFiles.map(f => f.name).join(', ');
  }

  onSelectExcel(event: any) {
    if (event.files && event.files.length) {
      const file = event.files[0];
      this.excelFile = file;
      this.lerExcel(file);
      this.activeStep = 1;
    }
  }

  onClearExcel() {
    this.excelFile = null;
    this.relatoriosExcel = [];
  }

  onSelectPDF(event: any) {
    this.pdfFiles = [...this.pdfFiles, ...event.files];
    console.log('PDFs selecionados:', this.pdfFiles.map(f => f.name));
    if (this.pdfFiles.length >= this.relatoriosExcel.length) {
      this.activeStep = 2;
    }
  }

  onClearPDF() {
    this.pdfFiles = [];
  }

  normalizeColumnNames(columns: string[]): string[] {
    return columns.map(col => col.trim().toUpperCase());
  }

  lerExcel(file: File) {
    const reader = new FileReader();
    reader.onload = (e: any) => {
      const data = new Uint8Array(e.target.result);
      const workbook = XLSX.read(data, { type: 'array' });
      const sheetName = workbook.SheetNames[0];
      const worksheet = workbook.Sheets[sheetName];
      const jsonData: any[] = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
      if (!jsonData || !jsonData.length) {
        this.messageService.add({
          severity: 'warn',
          summary: 'Planilha vazia',
          detail: 'Não há dados.'
        });
        return;
      }
  
      // Normalize column names
      const cabecalho: string[] = this.normalizeColumnNames(jsonData[0].map((val: any) => val?.toString().trim()));
      for (const col of this.colunasObrigatorias) {
        if (!cabecalho.includes(col)) {
          this.messageService.add({
            severity: 'error',
            summary: 'Coluna faltando',
            detail: `Coluna "${col}" não encontrada na planilha.`
          });
          this.excelFile = null;
          return;
        }
      }
  
      const dataObjects = XLSX.utils.sheet_to_json(worksheet, {
        defval: '',
        header: cabecalho,
        range: 1
      });
      const relSet = new Set<string>();
      (dataObjects as any[]).forEach(row => {
        if (row['RELATORIO']) {
          relSet.add(row['RELATORIO'].toString().trim());
        }
      });
      this.relatoriosExcel = Array.from(relSet);
      if (this.relatoriosExcel.length > 1) {
        this.messageService.add({
          severity: 'warn',
          summary: 'Vários RELATORIO',
          detail: `Planilha tem ${this.relatoriosExcel.length} valores distintos.`
        });
      }
      console.log('Relatórios Excel:', this.relatoriosExcel);
    };
    reader.readAsArrayBuffer(file);
  }

  enviarArquivosExcel() {
    if (!this.excelFile) {
      this.messageService.add({
        severity: 'warn',
        summary: 'Aviso',
        detail: 'Selecione a planilha Excel.'
      });
      return;
    }
    if (!this.pdfFiles.length) {
      this.messageService.add({
        severity: 'warn',
        summary: 'Aviso',
        detail: 'Selecione os PDFs.'
      });
      return;
    }
    if (this.pdfFiles.length < this.relatoriosExcel.length) {
      this.messageService.add({
        severity: 'error',
        summary: 'Faltam PDFs',
        detail: `Você tem ${this.relatoriosExcel.length} relatórios distintos, mas apenas ${this.pdfFiles.length} PDFs.`
      });
      return;
    }
    for (const relatorio of this.relatoriosExcel) {
      const pdfEncontrado = this.pdfFiles.some(pdf => {
        const nameNoExt = pdf.name.replace('.pdf', '').trim();
        return nameNoExt === relatorio;
      });
      if (!pdfEncontrado) {
        this.messageService.add({
          severity: 'error',
          summary: 'Nome divergente',
          detail: `Relatório "${relatorio}" não tem PDF correspondente.`
        });
        return;
      }
    }
    this.servicoLLM.uploadExcelMultiplosPdfs(this.excelFile, this.pdfFiles)
      .subscribe({
        next: (res) => {
          console.log('Resposta do backend:', res);
          if (this.excelFile) {
            this.lastUploadedExcel = this.excelFile.name;
          }
          this.lastUploadedPdfs = this.pdfFiles.map(pdf => pdf.name);
          this.excelFile = null;
          this.pdfFiles = [];
          this.relatoriosExcel = [];
          this.excelUploader.clear();
          this.pdfUploader.clear();
          this.messageService.add({
            severity: 'success',
            summary: 'Sucesso',
            detail: 'Excel e PDFs enviados com sucesso!'
          });
          this.getRmcKpmg();
        },
        error: (err: any) => {
          console.error('Erro ao enviar Excel+PDFs:', err);
          this.messageService.add({
            severity: 'error',
            summary: 'Erro',
            detail: err.error?.detail || err.message || 'Falha no upload.'
          });
        }
      });
  }

  getRmcKpmg() {
    this.servicoLLM.listarRelatoriosRcm().subscribe({
      next: (lista) => {
        this.rcmRelatorios = lista.map(item => ({
          ...item,
          relatorio: item.nome
        }));
      },
      error: (err) => {
        console.error('Erro ao buscar relatórios RCM:', err);
      }
    });
  }

  downloadRelatorio(relatorioId: number): void {
    const url = this.servicoLLM.getPdfUrl(relatorioId);
    window.open(url, '_blank');
  }

  deletarRelatorio(id: number) {
    // Chame o serviço que exclui o registro.
    // Supondo que o seu serviço tenha um método deletarRelatorioRCM que retorna um Observable.
    this.servicoLLM.deletarRelatorioRCM(id).subscribe({
      next: (res) => {
        this.messageService.add({
          severity: 'success',
          summary: 'Deletado',
          detail: 'Registro deletado com sucesso!'
        });
        // Atualiza a lista de registros
        this.getRmcKpmg();
      },
      error: (err) => {
        console.error('Erro ao deletar o registro:', err);
        this.messageService.add({
          severity: 'error',
          summary: 'Erro',
          detail: 'Falha ao deletar o registro.'
        });
      }
    });
  }

}

<p-toast></p-toast>

<div style="max-width: 1200px; margin: auto; font-family: Arial, sans-serif;">
  <h2 style="text-align: center; margin-bottom: 1rem;">Upload Recomendações KPMG</h2>

  <!-- Componente Steps para indicar o fluxo -->
  <p-steps [model]="steps" [activeIndex]="activeStep" [readonly]="true" [ngStyle]="{'margin-bottom': '1rem'}"></p-steps>

  <!-- Passo 1: Excel KPMG -->
  <div style="border: 1px solid #ccc; padding: 1rem; border-radius: 5px; margin-bottom: 1rem;">
    <h3 style="margin-bottom: .5rem;">Passo 1: Excel KPMG</h3>
    <p-fileUpload
      #excelUploader
      name="excelFile"
      accept=".xls,.xlsx"
      customUpload="true"
      [auto]="true"
      [showUploadButton]="false"
      [showCancelButton]="false"
      (onSelect)="onSelectExcel($event)"
      (onClear)="onClearExcel()"
    >
    </p-fileUpload>
    <div *ngIf="excelFile" style="margin-top: 0.5rem;">
      <small>Arquivo Selecionado: <strong>{{ excelFile.name }}</strong></small>
    </div>
  </div>

  <!-- Passo 2: Selecione os relatórios (PDFs) -->
  <div *ngIf="excelFile" style="border: 1px solid #ccc; padding: 1rem; border-radius: 5px; margin-bottom: 1rem;">
    <h3 style="margin-bottom: .5rem;">Passo 2: Selecione os relatórios</h3>
    <p-fileUpload
      #pdfUploader
      name="pdfFiles"
      accept=".pdf"
      customUpload="true"
      [auto]="true"
      [multiple]="true"
      [showUploadButton]="false"
      [showCancelButton]="false"
      (onSelect)="onSelectPDF($event)"
      (onClear)="onClearPDF()"
    >
    </p-fileUpload>
    <div *ngIf="pdfFiles.length" style="margin-top: 0.5rem;">
      <small>Arquivos Selecionados: <strong>{{ pdfFilesNames }}</strong></small>
    </div>
  </div>

  <!-- Passo 3: Botão final -->
  <div *ngIf="excelFile && pdfFiles.length >= relatoriosExcel.length" style="text-align: center; margin-bottom: 1rem;">
    <button pButton type="button" label="Upload Recomendações KPMG" style="font-size: 0.8rem; padding: .5rem 1rem;" (click)="enviarArquivosExcel()"></button>
  </div>

  <!-- Exibe os nomes dos arquivos enviados após o envio -->
  <div *ngIf="lastUploadedExcel || lastUploadedPdfs.length" style="margin-top: 1rem; border-top: 1px solid #ccc; padding-top: 1rem;">
    <h3 style="text-align: center;">Arquivos Enviados:</h3>
    <p *ngIf="lastUploadedExcel" style="text-align: center;"><strong>Excel:</strong> {{ lastUploadedExcel }}</p>
    <div *ngIf="lastUploadedPdfs.length">
      <p style="text-align: center;"><strong>PDFs:</strong></p>
      <ul style="list-style: none; padding: 0; text-align: center;">
        <li *ngFor="let pdfName of lastUploadedPdfs" style="display: inline-block; margin: 0 0.5rem;">
          {{ pdfName }}
        </li>
      </ul>
    </div>
  </div>
</div>

<!-- Tabela de registros (p-table) -->
<div class="card" style="max-width: 800px; margin: 2rem auto; font-family: Arial, sans-serif;">
  <h2 style="text-align: center;">Tabela de Relatórios RCM</h2>

  <!-- Filtro global -->
  <div style="text-align:right; margin-bottom:1rem;">
    <span class="p-input-icon-left">
      <i class="pi pi-search"></i>
      <input type="text" pInputText (input)="dt.filterGlobal($any($event.target).value, 'contains')" placeholder="Filtro global..." style="width: 200px;" />
    </span>
  </div>

  <p-table
  #dt
  [value]="rcmRelatorios"
  [paginator]="true"
  [rows]="5"
  [globalFilterFields]="['relatorio','data_emissao','constatacoes','recomendacoes']"
  sortMode="multiple"
  [responsiveLayout]="'scroll'"
>
<ng-template pTemplate="header">
    <tr style="font-size: 0.7rem;">
      <th pSortableColumn="relatorio">
        Relatório
        <p-sortIcon field="relatorio"></p-sortIcon>
      </th>
      <th pSortableColumn="data_emissao">
        Data Emissão
        <p-sortIcon field="data_emissao"></p-sortIcon>
      </th>
      <th pSortableColumn="constatacoes">
        Constatações
        <p-sortIcon field="constatacoes"></p-sortIcon>
      </th>
      <th pSortableColumn="recomendacoes">
        Recomendações
        <p-sortIcon field="recomendacoes"></p-sortIcon>
      </th>
      <th style="text-align: center;">Ações</th>
    </tr>
  </ng-template>

  <ng-template pTemplate="body" let-rel>
    <tr style="font-size: 0.7rem;">
      <td>{{ rel.relatorio }}</td>
      <td>{{ rel.data_emissao }}</td>
      <td>{{ rel.constatacoes }}</td>
      <td>{{ rel.recomendacoes }}</td>
      <td style="text-align: center;">
        <!-- Botão de excluir -->
        <button pButton type="button" icon="pi pi-trash" style="font-size: 0.7rem; padding: 0.3rem" (click)="deletarRelatorio(rel.id)"></button>
        <!-- Botão de detalhes -->
        <button
          pButton
          type="button"
          label="Detalhes"
          style="font-size: 0.7rem; padding: 0.3rem 0.5rem; margin-left: 0.3rem"
          [routerLink]="['/chatdetalhe', rel.id]"
        ></button>
        <!-- Botão de download -->
        <button
          pButton
          type="button"
          label="Download"
          style="font-size: 0.7rem; padding: 0.3rem 0.5rem; margin-left: 0.3rem"
          (click)="downloadRelatorio(rel.id)"
        ></button>
      </td>
    </tr>
  </ng-template>
</p-table>

import { Injectable } from '@angular/core';
import { HttpClient, HttpErrorResponse, HttpHeaders } from '@angular/common/http';
import { BehaviorSubject, Observable, of, throwError } from 'rxjs';
import { catchError, map } from 'rxjs/operators';
import { environment } from '../environments/environment';

import { MensagemPayload } from './models/models';

import { FeedbackPayload } from './models/models';

import { MensagemPayloadGeral } from './models/models';

// No seu servico-llm.service.ts
export interface RcmRelatorio {
  id: number;
  nome: string;
  data_emissao: string | null;
  constatacoes: string;
  recomendacoes: string;
}


@Injectable({
  providedIn: 'root'
})
export class ServicoLLMService {

  private APIprod = 'http://10.2.96.55:5000/api';

  //private API_LOCAL = 'http://192.168.2.80:5002/apilocal';
  //private API = 'http://192.168.2.80/api';
//private API_ptai = 'http://192.168.2.80:5002/apiptai';
//private API_ptaiDocker = "http://192.168.2.80:5002/apiptai"

private API_ptaiDocker = "https://mefis.aud.bb.com.br/apiptai"
private API_ptai = 'https://mefis.aud.bb.com.br/apiptai';
private API = "https://mefis.aud.bb.com.br/api"
//private API_ptai_ = "https://mefis.bb.com.br/apiptai"

  // =============================
  // ARMAZENAMENTO DE USUÁRIO
  // =============================
  private userSubject = new BehaviorSubject<any>(null);
  /** Observable para quem quiser “ouvir” mudanças no usuário. */
  public user$ = this.userSubject.asObservable();

  // =============================
  // CONSTRUTOR
  // =============================
  constructor(private http: HttpClient) {}

  // =============================
  // MÉTODOS DE GESTÃO DO USUÁRIO
  // =============================
  /**
   * Define o usuário atual no BehaviorSubject.
   */
  setUser(user: any) {
    this.userSubject.next(user);
  }

  /**
   * Retorna o valor atual do usuário (sem precisar se inscrever).
   */
  getUser() {
    return this.userSubject.value;
  }

  // =============================
  // MÉTODOS DE AUTENTICAÇÃO
  // =============================
  authFunci(goto: any) {
    return this.http.post<any>(`${this.API_ptai}/auth/`, goto);
  }

  getFuncionario() {
    return this.http.get<any>(`${this.API}/authrest`);
  }

  getAuthFunci() {
    return this.http.get<any>(`${this.API}/authrestfunci`);
  }

  /**
   * Chama o backend para autenticar via corpo (com goto e environment).
   * Se retornar user, armazenamos no BehaviorSubject para uso global.
   */
  getauthrestfunci(goto: string): Observable<any> {
    if (!goto) {
      console.error('Parâmetro "goto" é obrigatório.');
      return throwError(() => new Error('Parâmetro "goto" é obrigatório.'));
    }
    
    const body = {
      goto,
      environment: environment.environmentName,
    };
  
    return this.http.post<any>(
      `${this.API_ptai}/authrestfunci/`,  // URL
      body,                               // Corpo da requisição
      { withCredentials: true }           // Opções: envia cookies
    ).pipe(
      map((response) => {
        if (response?.redirectUrl) {
          window.location.href = response.redirectUrl;
        }
        return response;
      }),
      catchError((error) => {
        console.error('Erro na autenticação:', error);
        return throwError(() => new Error('Erro ao autenticar. Por favor, tente novamente.'));
      })
    );
  }

  // =============================
  // MÉTODOS DE CHAT E OUTROS
  // =============================
  sendMessage(
    sessionId: string,
    userMessage: string,
    roleUser?: string,
    roleAssistant?: string
  ): Observable<any> {
    const body = { sessionId, userMessage, roleUser, roleAssistant };
    return this.http.post<any>(`${this.API_ptai}/chat`, body).pipe(
      catchError((error: HttpErrorResponse) => {
        let errorMessage = 'Erro desconhecido. Por favor, tente novamente mais tarde.';

        if (error.error instanceof ErrorEvent) {
          // Erro do lado do cliente
          errorMessage = `Erro do cliente: ${error.error.message}`;
        } else {
          // Erro do lado do servidor
          switch (error.status) {
            case 400:
              errorMessage = 'Requisição inválida. Verifique os dados enviados.';
              break;
            case 500:
              errorMessage = 'Erro interno no servidor. Por favor, tente novamente mais tarde.';
              break;
            default:
              errorMessage = `Erro (${error.status}): ${error.message}`;
          }
        }

        console.error('Erro na chamada ao backend:', error);
        return throwError(() => new Error(errorMessage));
      })
    );
  }

  getTrabalhos(request: { nome: string; ano: number }): Observable<any[]> {
    return this.http.post<any[]>(`${this.API_ptai}/chat_trabalhos/`, request);
  }

  getTrabalhoDetails(nr_trabalho: number): Observable<any> {
    return this.http.post(`${this.API_ptai}/chat_trabalho/`, { nr_trabalho });
  }

  createSession(): Observable<{ sessionId: string }> {
    return this.http.post<{ sessionId: string }>(`${this.API_ptai}/create_session`, {});
  }

  resetSession(sessionId: string): Observable<any> {
    const body = { sessionId };
    return this.http.post(`${this.API_ptai}/reset_session`, body);
  }

  // ... dentro da classe ServicoLLMService



salvarMensagem(payload: MensagemPayload): Observable<any> {
  // Ajuste a URL conforme sua configuração
  const url = `${this.API_ptai}/msgchatdest/`;
  return this.http.post<any>(url, payload).pipe(
    catchError((error) => {
      console.error('Erro ao salvar mensagem:', error);
      // Retornar um observable completado em erro não precisa interromper a UI
      return of(null);
    })
  );
}


salvarChatGeral(payload: MensagemPayloadGeral): Observable<any> {
  // Ajuste a URL conforme sua configuração
  const url = `${this.API_ptai}/msgchatgeral/`;
  return this.http.post<any>(url, payload).pipe(
    catchError((error) => {
      console.error('Erro ao salvar mensagem:', error);
      // Retornar um observable completado em erro não precisa interromper a UI
      return of(null);
    })
  );
}

salvarFeedback(payload: FeedbackPayload): Observable<any> {
  const url = `${this.API_ptai}/feedback`;  // Ajuste conforme necessário
  return this.http.post<any>(url, payload).pipe(
    catchError((error) => {
      console.error('Erro ao enviar feedback:', error);
      return throwError(() => error);
    })
  );
}

servicosAgentes(payload: { [key: string]: string }): Observable<any> {
  const url = `${this.API_ptai}/agentesllm/`; // Endpoint no FastAPI
  console.log(url)
  return this.http.post<any>(url, payload).pipe(
    catchError((error) => {
      console.error('Erro ao enviar dados dinâmicos:', error);
      return throwError(() => new Error('Erro ao enviar dados dinâmicos.'));
    })
  );
}


trbpln(rota: any, json: any): Observable<any[]> {
  return this.http.post<any[]>(`${this.API_ptaiDocker}/${rota}/`, json);
}

getAtb(rota: any, json: any): Observable<any[]> {
  return this.http.post<any[]>(`${this.API_ptaiDocker}/${rota}/`, json);
}

getPDF(rota: any): Observable<any> {
  return this.http.get(`${this.API_ptaiDocker}/${rota}/`, { responseType: 'blob' });
}

uploadDocumento(rota: string, file: File, nome: string): Observable<any> {
  const formData = new FormData();
  formData.append('file', file);

  const headers = new HttpHeaders({
    'enctype': 'multipart/form-data' // Adicione o cabeçalho de Content-Type
  });
    const url = `${this.API_ptaiDocker}/${rota}/?nome=${nome}`;
  return this.http.post<any>(url, formData, { headers, reportProgress: true, observe: 'events' });
}

uploadRelatorioRCM(
  file: File,
  nome: string,
  data: string,
  constatacoes: string,
  recomendacoes: string
): Observable<any> {
  const formData = new FormData();
  formData.append('file', file);
  formData.append('nome', nome);
  formData.append('data', data);
  formData.append('constatacoes', constatacoes);
  formData.append('recomendacoes', recomendacoes);

  // Ajuste a URL para o endpoint que criamos no FastAPI:
  // /apiptai/rcmkpmg
  const url = `${this.API_ptai}/rcmkpmg`;

  return this.http.post<any>(url, formData, {
    reportProgress: true,
    observe: 'events', // se quiser acompanhar progresso
  }).pipe(
    catchError((error) => {
      console.error('Erro ao enviar relatório RCM:', error);
      return throwError(() => error);
    })
  );
}

uploadExcelMultiplosPdfs(excel: File, pdfs: File[]): Observable<any> {
  const formData = new FormData();
  // Adiciona o arquivo Excel
  formData.append('file_excel', excel);

  // Adiciona cada PDF com um nome único
  pdfs.forEach((pdf, index) => {
    formData.append(`file_pdf_${index}`, pdf, pdf.name);
  });

  // Defina a rota de destino
  const url = `${this.API_ptai}/upload-rcm-excel-multiplos`;

  return this.http.post<any>(url, formData).pipe(
    catchError((error) => {
      console.error('Erro ao enviar Excel + múltiplos PDFs:', error);
      return throwError(() => error);
    })
  );
}

listarRelatoriosRcm(): Observable<RcmRelatorio[]> {
  const url = `${this.API_ptai}/listar_rcm_relatorios`;
  return this.http.get<RcmRelatorio[]>(url).pipe(
    catchError((error) => {
      console.error('Erro ao listar rcm_relatorios:', error);
      return throwError(() => error);
    })
  );
}

deletarRelatorioRCM(id: number): Observable<any> {
  const url = `${this.API_ptai}/deletar_rcm_relatorio/${id}`;
  return this.http.delete(url).pipe(
    catchError((error) => {
      console.error('Erro ao deletar relatório:', error);
      return throwError(() => error);
    })
  );
}

getPdfUrl(relatorioId: number): string {
  return `${this.API_ptai}/rcmkpmg/${relatorioId}`;
}


}





